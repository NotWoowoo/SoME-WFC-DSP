<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="An Interactive DSP Guide">
    <meta name="og:image" content="img/cat-spin.gif">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="img/favicon/favicon-light.png" rel="icon" type="image/png" media="(prefers-color-scheme: light)"/>
    <link href="img/favicon/favicon-light.svg" rel="icon" type="image/svg+xml" media="(prefers-color-scheme: light)"/>
    <link href="img/favicon/favicon-dark.png" rel="icon" type="image/png" media="(prefers-color-scheme: dark)"/>
    <link href="img/favicon/favicon-dark.svg" rel="icon" type="image/svg+xml" media="(prefers-color-scheme: dark)"/>
    <link href="dist/main.css" rel="stylesheet">
    <title>Audio Programming Tutorial</title>
</head>
<body class="dark:bg-black">
    

    <div class="bg-slate-200 dark:bg-slate-800 dark:text-white py-2 shadow-sm"> 
        <h1 class="text-center text-3xl">DSP For Audio Programming</h1>
        <h3 class="text-center text-xl">An Interactive Guide by Sean McGoff and not_woowoo</h3>
    </div>
    

    <p class="text-center my-2" >
        <button onclick="toggleEverything(this)" class="button-colors rounded-md px-2 py-1 mx-1">Show Everything</button>
        <button id="darkmode-btn" onclick="invertTheme()" class="button-colors rounded-md px-2 py-1 mx-1"></button>
    </p>

    <!--ABOUT DROPDOWN-->
    <div class="dropdown root-dropdown">
        <h3 class="section-title">&#8594; <b>About</b></h3>
        <div class="section-body">
            <p>This website is designed to teach enough digital signal processing (DSP) in order for you to be able to start your journey into programming audio software. Whether you want to create VST plugins for digital audio workstations, add complex audio to your website / application / game, or just want to pick up a new skill, this free course will give you a great foundation in DSP.</p>
            <p>For those interested in what technology powers this site, we are using Github Pages to host the website, Tailwind CSS to style the pages, Desmos' API to create the interactive visualizations, and C++ (compiled into web assembly) for the editing environments. The public GitHub repository can be found 
            <a href=”https://github.com/NotWoowoo/SoME-WFC-DSP”>here</a>.</p>
        </div>
        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; How to use this website</h3>
            <div class="section-body">
                <p>This website is organized into a tree of dropdown menus, each expanding on subjects in higher level dropdowns (such as this "How to use this website" dropdown).</p>
                <p>To get the most out of this site, it's recommended to start by reading everything (with "Expand Everything" if you prefer). Once you have gone through the information once, specific information is easily accessable by navigating the dropdowns.</p>
            </div>
        </div>
        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Prerequisite knowledge</h3>
            <div class="section-body">
                <p>While we do aim to make this course beginner friendly, there are a couple things that we recommend that you learn before starting this course. The programming sections use Javascript as the language, so we recommend learning the fundamentals of programming and the Javascript language before trying the programming sections. As for the math in this course, it should be accessible to anyone who has taken a pre-calculus course or higher.</p>
            </div>
        </div>
    </div>

    <!--SECTION 1 DROPDOWN-->
    <div class="dropdown root-dropdown">
        <h3 class="section-title">&#8594; <b>Section 1:</b> What is digital audio, really?</h3>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; The Wide World of DSP</h3>
            <div class="section-body">
                <p>It seems pretty reasonable that in order to understand how to process digital audio, you must first understand what digital audio is. As you'll soon find out, digital audio is merely a category of a larger kind of digital data called signals. Signals are that new beat you spent all night working on, the readings from an EKG sensor, seismic data from geophones, and even images of cats on the internet! The point is that while this course is specifically geared towards digital audio in particular, that is far from the only application of this course's material. If you want more information on DSP's applications in image processing and data compression, I'd recommend looking through Chapters 23 to 27 of <a href="http://www.dspguide.com/">Dr. Steven W. Smith's “The Scientist and Engineer's Guide to Digital Signal Processing”</a>
                </p> 
            </div>
        </div>
        
        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Analog vs Digital</h3>
            <div class="section-body">
                <p>What even is analog? Why does that older fellow in the music store keep insisting that his dusty old analog synthesizers sound so much warmer and natural than the modern digital trash? Does he even know what the word “analog” means? Since the D in DSP stands for “digital,” it only makes sense to start by explaining the difference. Before computers became the standard for audio processing, the main option for synthesizing and processing audio came in the form of dedicated electronic circuits. The sound waves in these circuits were represented through fluctuations of voltage over time. In other words, the fluctuations in voltage were an <i>analog</i> of the actual signal it represents (and that's why it's called "analog." The older meaning of the word "analog" is a noun and synonymous with words like "comparable" or "representation")! Since analog signals are represented by changes in energy, and physical levels of energy can't jump from one value to another in 0 units of time, the resulting signal is continuous. In other words, if you attached a polygraph machine to the source of an analog signal, and traced your finger across the resulting curve, you would never have to pick up your finger; the polygraph's position won't teleport from one position to another. To answer the question about the older fellow in the music store, there is some truth to his claim that analog synths can sound more natural. Electronic components like resistors and capacitors are prone to minor fluctuations in their current, voltage, and resistance. The result of this interference is noise which gives analog signals their characteristic warmth.</p>
                <div class="flex justify-center">
                    <img src="img/polygraph.jpeg">
                </div>
                <p>In comparison, digital signals are discrete. Rather than a continuous curve, the polygraph would show a set of evenly spaced points for a digital sound source. This method works well for computers as you can store a digital signal pretty efficiently on a hard drive, while you would need an infinite amount of storage space to store an analog one. Since computers store signals using lists of numbers that represent sound rather than the continuous voltage signals in analog circuits, digital signals don't suffer from the same noise interference that analog signals do. Since our application is audio programming, we will only focus on digital signals from now on.</p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Signals, Samples, Amplitude, and Sample Rate</h3>
            <div class="section-body">
                <p>So, what is this signal? A signal is a list of numbers over a fixed rate of time. In the case of audio, the numbers are known as the “samples” and they measure the “amplitude” at each sample's point in time. Typically, amplitude is denoted as a decimal value between -1 and 1. The way I like to think about amplitude is by imagining the cone of a speaker. An amplitude of 1 means the cone is pushed all the way out, and -1 is pulled all the way in. From the rapid movement of the cone's position over time, you get sound. The fixed rate of time is known as the “sample rate”, which is commonly measured in samples per second. The most common sample rate in music is 44.1khz, or 44,100 samples per second.</p>
                <div class="flex justify-center">
                    <div id="sampleRateDesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; <i>Try it Yourself</i>: Your First Waveform</h3>
            <div class="section-body">
                <p>We've been doing an awful lot of talking, so it's only fair now to let you do some programming. In addition to the lessons, we have included a playground where you can test out your audio programming skills, make cool sounds, and share your creations. This playground uses a slightly modified version of javascript, where the editor exists inside a function “processAudio” that expects a sample to be returned at the end of your code. Also, we have included aliases for multiple useful functions such as shortening Math.sin() to just sin().</p>
                <p>Without further ado, here's your first exercise. You might have noticed that for the examples, we have been using a sine wave. The filled in code produces a sine wave, but a very slow one. You first want to speed that wave up so that it's audible (You can peek ahead to the frequency section if you get stuck). Next, try adjusting the amplitude of the wave (without adjusting the volume slider). Finally, try experimenting with adding sine waves of different speeds and amplitudes together. You can start the exercise <a href=".?code=PTAEGEAsEMBtYKYDsDmDQEYBcoDKAHBBAE1ABdIBLAZ1GsqXQHdoA3dAV3zoHtQBPHh1ABjaElCQE0AE6hKZAIQAoEBBjxkaUACYcAFQ4yJFdPUagW7UMR5MJACiYLIQsuSEiqqclNCseWA4AWzNYSmIEGQBKVTAoOERUdABmHABRAA9CGUpQpHdnClBgjlgySnxEOgZmNgRaaGJI0jIeNFMZZRkEMiMJcwcK0OigA%3D%3D">here</a>.</p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Bit Depth and the "Retro" Sound</h3>
            <div class="section-body">
                <p>Computers, and especially older ones, have a hard time accurately storing non-whole numbers. Since a digital audio signal's values are non-whole numbers by nature, that creates a limitation on how precise each value can be. In DSP, this precision is known as the “Bit Depth” of a digital signal. The bit depth is merely the amount of bits required to hold said number (<a href="https://web.stanford.edu/class/cs101/bits-bytes.html">Here</a> is a good resource to understanding bits and binary numbers). Most modern digital audio workstations use a standard bit depth of 32 bits, meaning that there are 2<sup>32</sup> possible values a sample can have between -1 and 1. Converting to lower bit depths forces samples' amplitudes to be quantized (snapped to the closest intermediate value). The effect of this is a noiser audio signal that sounds characteristically "retro" (since old hardware had lower bit depths).</p>
                <p>[two files to compare of different bit depths maybe]</p>
                <div class="flex justify-center">
                    <div id="bitDepthDesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; <i>Try It Yourself</i>: Your First Effects</h3>
            <div class="section-body">
                <p>Let's put that knowledge of bit depth to good use now. For your first audio effect, you will be building a <b>downsampler</b>. A downsampler, also known as a decimator, takes an audio signal of one sample rate, and plays it as if it was another lower sample rate. For example, if you want to halve the sample rate, you can output a variable which only updates for every other sample. To cut the sample rate by a third, you would only update the variable every third sample, and so on. This has the effect of creating buzzing high pitched artefacts in the sound (you can hear this effect in songs like <a href="https://www.youtube.com/watch?v=2oIAQSUt9mo">Edge by Rezz</a>). In the starter code, we have defined a persistent output variable (global.output), a sine wave input (input), and a parameter for the intensity of the downsampling (b). The output variable is persistent (by being in the global object), because all other variable declarations/definitions are executed for every sample and can't persist across multiple samples. Your job is to edit the program such that the output updates every b-th sample. (hint: what does a percent sign do in javascript?)
                <br />
                <a href=".?code=OYGw9gRghiDKCmAXAFAcjAV0QBy6gNAAQAMAlIQPQVQDGN8Azg4QG4CWUhokMAdJjiwAoEEkJsAdrkSEAvIQaTkAJgBUABQCSqxGwC28VcuVkhIsRDmEAjMTNVCAYQAWMURODwAXIQzYAJlCI8Fzg0CD8WNKEAGZgAE6EYBIgAJ6E8Czw8ekQALSIzgpQetiiSTHiUsIOAHIA8gAqAKI%2BqZioICCEEvDw%2FoSIYL4MIYUhAEQMJWXwtRh6ENkTrFDxHBCivEIOAJqYhDRQEknY8CfjhBMAEmAA7oSNzmzMAOoJANYMK%2F7xYAH3E5xRJ6BIhfpsIaJSTAvRBNjJMzxJAYeInbjhSKCRBAA">Downsampler Starter Code</a>
                <br />
                <a href=".?code=OYGw9gRghiDKCmAXAFAcjAV0QBy6gNAAQAMAlIQPQVQDGN8Azg4QG4CWUhokMAdJjiwAoEEkJsAdrkSEAvIQaTkAJgBUABQCSqxGwC28VcuVkhIsRDmEAjMTNVCsMCCxswEoWwBmyBlD3YogByGHoQ8ABOhACkhJayCSSkQoSpXODQIPxY0laS0mYRSBgREuk8WQLSQA">Downsampler Solution Code</a>
                </p>
                <br />
                <p>If you're up for a bit of a harder challenge, you can try building a <b>bitcrusher</b>. A bitcrusher is a common effect that takes a signal with a high bit depth and “crushes” it down to a lower bit depth by rounding the samples to the nearest evenly spaced value. For example, if the bit depth was set to 2, the values that the wave will snap to are -1, -0.5, 0.5, and 1. For a bit depth of 3, it would be -1, -0.75, -0.5, -0.25, …, 0.75, 1. In the starter code, you are given two variables: a sine wave signal (wave) and a bit depth (b). Your goal is to quantize the signal into 2b evenly spaced values between 0 and 1. (Hint: using the round() function could be useful, if you could change the range of the wave to make it work).
                <br />
                <a href=".?code=DYUwLgBA7ghgbiCBeCBnAlgOwBQCYIBUEACgJKEQAslADBWOgLYgCUAUKJAEbIS5tsA9IIDCACxjBQmAOYgAXBADKmGAAcIYMYjiSAriFQQA9gDNN26PERhjEHiASZgATzRqYAYxAATCLuADIy5wKBAQTAgAWgBGCBhMPxiAOjYAJ3A9NMjYBDYgA%3D%3D%3D">Bitcrusher Starter Code</a>
                <br />
                <a href=".?code=DYUwLgBA7ghgbiCBeCBnAlgOwBQCYIBUEACgJKEQAslADBWOgLYgCUAUKJAEbIS5tsA9ETYBlAPbAArg3GYAXBC4BPCI3FwsAcwhgAFogBOMTFsQAzQ%2BMYQ6YcX10Gl%2BiAAdxUEIbVYpqCABGABoIKylMABNtCDZ7J0RMEBhDEFRILDAQM0NQk0iEzDUNGP0jEzMlGABjAGtdB2wAWhCgllCvCGqTNEwYNzYQBENVOBhpRHieoZBMYFVUNxqQArGJpXAvWYgWiHyggDo2AkEBQUEIABU9dADbvYh%2FEHMpYAgxw3QYLlAGiD14CAOOA1LwPFA8KEuCwdkEzhcALIaRCwBBhCqTRo0UKMdicCAAL284ku4lwXEYflQgV42BoBwArBRsKjEABqNowoiMeFhcQRArxJIpNIZTBZHJsIlWUnkymYfw0lDhKLYaUkskUqmBdhCRHI6CA9GmRBcGr1eLNVo6vZRMLgKSGTBsVJgR1FfBENXE2VahXUiAXXGwwJsIA%3D%3D">Bitcrusher Solution Code</a>
                </p>
            </div>
        </div>

    </div>


    <!--SECTION 2 DROPDOWN-->
    <div class="dropdown root-dropdown">
        <h3 class="section-title">&#8594; <b>Section 2:</b> Frequency</h3>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; What is Frequency?</h3>
            <div class="section-body">
                <p>Until now, we have only been looking at digital audio in the time domain (where time is the horizontal axis of the graph), but a great deal of information can be dissected from the frequency domain as well. To introduce frequency, let's think about this cat spinning on a record player.</p>
                <div class="flex justify-center">
                    <img src="img/cat-spin.gif">
                </div>
                <p>We can measure the “frequency” by finding how many times the cat makes a full rotation per unit time. The standard unit for frequency is the hertz (hz), or cycles/second. Since the cat is spinning on a 33 rpm (revolutions per minute) record, we can find the revolutions per second by dividing 33 by 60. Therefore, we can find that the cat is spinning at a frequency of 0.55 hz, or roughly one full rotation for every 1.8 seconds.</p>
                <p>The best equivalent to this spinning cat in the world of DSP is the sine wave. Much like the GIF of the cat, sine waves are periodic, or repeat infinitely in a very predictable manner. Because of this property, we can measure a sine wave's frequency in a similar way. The frequency of a sine wave is 1 divided by the “period” of the wave, or the time it takes to complete one cycle.</p>
                <div class="flex justify-center">
                    <div id="frequencyDesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; What is Phase?</h3>
            <div class="section-body">
                <p>While frequency is the amount of cycles per second, phase is the starting position of the cycle. Phase is measured in either degrees or radians depending on the context (in this section we use degrees). Yet again, let's think about these <i>two</i> gifs of cats spinning on a record player.</p>
                <div class="flex justify-center overflow-hidden">
                    <img src="img/cat-spin-phase-1.gif">
                    <img src="img/cat-spin-phase-2.gif">
                </div>
                <p>Both cats are spinning at the same frequency, and both GIFs are 28 frames long, but what differentiates the two felines is their starting position on the first frame. Cat number one starts facing the camera, while cat number two starts by facing away from the camera. In DSP terms, we would say that these cats are “out of phase” with each other. Now, compare that to these cats below.</p>
                <div class="flex justify-center overflow-hidden">
                    <img src="img/cat-spin-phase-3.gif">
                    <img src="img/cat-spin-phase-3.gif">
                </div>
                <p>This time, the cats are “in phase” with each other because they start at the same point in their cycle around the record player. In the context of DSP, signals that are added together can either interfere constructively or destructively depending on each signal's respective phases. If you play around with the graph below, you'll see how the individual sine waves constructively interfere when they are at the same phase, and weaken the signal the more they differ. If you put one wave at 0 degrees, and the other at 180 degrees, the two waves cancel each other out completely (this phenomenon has the convenient name of “phase cancellation”).</p>
                <div class="flex justify-center">
                    <div id="phaseDesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Everything is Sine Waves!</h3>
            <div class="section-body">
                <p>While a sine wave's signal can be described as having a single frequency, most audio signals are not a simple sine wave. For instance, take a look this signal which is the sum of <i>two</i> sine waves where the second has a higher frequency and lower amplitude than the first:</p>
                <br/>
                <div class="flex justify-center">
                    <img width=400 src="img/sine-sum.png">
                </div>
                <br/>
                <p>Instead of assigning this complicated signal a single frequency value, it can be thought of as having two coexisting frequencies. If you graph this signal in the frequency domain instead of the time domain, you can see two distinct peaks which represent the amplitude of each sine wave in the original signal.</p>
                <br/>
                <div class="flex justify-center">
                    <img width=400 src="img/sine-sum-fourier.png">
                </div>
                <br/>
                <p>The horizontal position of each peak represents the frequency of each sine wave (higher frequencies are further right than lower ones), and the height of each peak represents the amplitude of each sine wave (amplitude in this case is the value which each sine function is multiplied by). The various smaller peaks are just debris from the method used to convert this signal from the time domain to the frequency domain: <b>the Fourier Transform!</b> In the 1800s, French mathematician Joseph Fourier discovered that ANY signal can be decomposed into a sum of many (or few) sine waves with different amplitudes, frequencies, and phases. The first <i>wave</i> is known as the “DC component," and is a flat line that represents the average amplitude of the signal. Each succeeding sinusoidal wave has a frequency that is an integer multiple of the first wave after the DC component (DC can be thought of having a frequency of 0 for convenience). In some cases, this sum can be infinite, but for digital signals, there is a finite limit (this idea will be explored when we talk about the Nyquist Sampling Theorem). As this is an introductory exploration into DSP, we aren't going to go into the details of how the Fourier Transform works specifically. If you are interested in that, 3blue1brown has a <a href="https://www.youtube.com/watch?v=spUNpyF58BY"> great video</a> on the <i>how</i> of Fourier.</p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; The Vocabulary of Frequency</h3>
            <div class="section-body">
                <p>As we briefly touched on in the previous section, a lot of language surrounding frequency and the frequency domain is abstracted from the actual concepts. The ideas of harmonics, pitch, and timbre are intimately tied with the idea of frequency, even if the hobbyist musician doesn't necessarily think of them in this way. For example, if you ever hear a musician talking about “harmonics”, they are merely talking about what you know as the frequency components of a sound. For any given sound, there is a “fundamental” harmonic/frequency, which is the lowest frequency of a sound, and then its “overtones”, or subsequent harmonics above the fundamental. The “pitch” of a sound is determined by the frequency of the fundamental, while the timbre (a fancy french word for the <i>sound</i> of a sound) is determined by the overtones of a sound. In the example below, you can add overtones to a fundamental sine wave and watch the signal morph into what is called a “square wave”, which is a signal that regularly alternates between a positive and negative value, such that the signal is positive 50% of the time and negative the other 50% of the time.</p>
                <div class="flex justify-center">
                    <div id="squareDesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>
                <p>Below is a similar example, but this time, the harmonics added turn the fundamental sine wave into a “sawtooth wave”, which is given its name by how it looks like the teeth of a saw blade.</p>
                <div class="flex justify-center">
                    <div id="sawtoothDesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>
                <p>So what makes these signals look different? In the case of the sawtooth wave, the overtones are added at every integer multiple of the fundamental frequency, at an amplitude of 1 divided by the number of the harmonic (the first overtone will be half as strong as the fundamental, the second will be one third, and so on). For the square wave, only the harmonics with a frequency with an odd multiple of the fundamental are added. For more complicated sounds, such as guitars and pianos, these harmonics will be much less orderly than basic shapes such as square and sawtooth waves, and are subject to change over time. For example, the start of a piano has a lot of high frequency content as the mallet hits the string, but over time, those higher harmonics are dampened out.</p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Nyquist Sampling Theorem and Aliasing</h3>
            <div class="section-body">
                <p>The Nyquist Sampling Theorem connects two of the concepts that we touched on previously: sample rate, and frequency. One of the main limitations of digital audio is the fact that it can only be precise to a finite amount. We explored this idea in the section about bit depth by talking about how lower bit depths quantize a digital signal, but there exists another form of digital information loss known as <i>aliasing</i>. When digitally sampling an analog signal, the highest frequency that a system can accurately store is equal to one half of the sampling rate of the system. This frequency is known as the “nyquist frequency”. This theorem is one of the main reasons why the most common sampling rate for digitally storing music is 44.1khz. Humans can only hear sounds up to about 20khz, which is close to half of 44.1khz (with a bit more room for good measure). When a wave containing frequencies higher than a sampler's nyquist frequency is sampled, aliasing occurs, where extra frequency content is introduced. By interacting with the graph below, you can see the effects that sampling a sine wave at different frequencies and sample rates has. The two sliders are scaled such that when they are lined up, the sine wave will be at the sampling rate's corresponding nyquist frequency. Pushing the frequency slider to the right of the sample rate slider shows the effects of aliasing, where the samples collected incorrectly introduce a sine wave that didn't exist in the source signal. </p>
                <div class="flex justify-center">
                    <div id="nyquistDesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>    
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; <i>Try it Yourself</i>: Basic Shapes</h3>
            <p>Now that we understand how frequencies work, we can now make basic shapes other than sine waves using a process known as <i>Additive Synthesis</i>. Additive Synthesis is merely the process of creating sounds using the sum of sine waves at different frequencies, phases, and amplitudes. In the starter code, we are using a for loop to create a sawtooth wave, where each harmonic is at an amplitude of 1 divided by the harmonic number. Your first challenge is to make this code produce a square wave. If you remember from the “Vocabulary of Frequency” section, a square wave contains only odd numbered harmonics. If you feel good about that, try producing a triangle wave. Similarly to square waves, triangle waves only contain odd harmonics. What differs is that the phase of each harmonic is a 180 degree turn from the previous harmonic (which is equivalent to multiplying the wave by -1). Additionally, the amplitude of each harmonic dampens by 1 over the harmonic number squared (or the harmonic number to the -2nd power). In this exercise, we have also included possible solutions for each challenge with comments explaining how they work.</p>
            <ul>
                <li><a href=".?code=PTDCAsEMBtoUwHYHM4AICMAuVBZSBrNAF3AEsBnVAYwHsATNABwCd6BXKtSVcgRzcjM0Ad0gA3OACgQAIRoI25bHkKoSFavSas6HLmualIyeKlETJ8IqgBmqALyoALE4AMqEDaH9EVAJ6WcNYIDqjuIDRsRIxRPJAAtozwgdbgoQCs4cAK8QBGcMyoNHZQzPHypFTkkjY0zAAUVqikoegA3M2oADyo4B2kANT26ACUqADekqjTqCFDqPXoHs1jAFQ8pAj1AEyo6wAKAJJ7tict60Sk8XBjkgC%2BkpJCRGzMIa4AdOknCEA%3D%3D%3D">Starter Code</a></li>
                <li><a href=".?code=PTAEGEAsEMBtYKYDsDmDQEZQGUD2sBXAFwEtckAoRI0AM1AF5QAWZgBioRqUdA%2BtCReAVg4hQJUElwB3UClwIAznQBOuALaYANKADMu4buhIAJqCW5Q5AHR2KtXKoAUAyUwwBuCaAA8g7xIAagYAJgBKUABvClA4qVAQ0GcsMBJIgCoLEiRnUNAsgAUASQK6Msks0g0ESIoAXwoKVS4CVR42G2EypCA%3D">Challenge 1 Solution</a></li>
                <li><a href=".?code=PTAECEHsDsFcGdQGEAWBDANhgptA5tqAMqQawAuAljAFA7mgBmoAvKACzsAMd2D0rUD3qgUggKw9GkAE4AKEZUEBGANyglAHlHrKAahbKAlKADeNUJdAhQAFRSVEAd0pZQAI0LkUhRjOwAjrC4AMYAnqAAtrAYVAAOGJTYMkyyoNhoIWLoMpEwlCEWViIoAHKwkYJyAEygAFQaJgC0oMpFljZxkE5yTcoANI1MiXGI3oRx6PCETg44oF09ZRWD1SYAJmiRcbhjPqBbCZTksOvY7aACBgvdvQNDDYtyy5GDTWv1oPCU0DWfAAoASU%2BzAaL0%2BVEi2BMNAAvjQaP4TjIBFwAHTiT7QIA%3D%3D%3D">Bonus Challenge Solution</a></li>
            </ul>
        </div>
    </div>

    <!--SECTION 3 DROPDOWN-->
    <div class="dropdown root-dropdown">
        <h3 class="section-title">&#8594; <b>Section 3:</b> Modulation, Making Music, and Miscellaneousness</h3>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Modulation and LFOs</h3>
            <div class="section-body">
                <p>As cool as the basic shapes might sound, they are, for lack of a better term, a little <i>basic</i>. Unless you're making music for a game on an atari 2600, you'll probably want more dynamic sounds than just square and sawtooth waves. One of the ways that you can escape the depths of monotony is through changing the parameters of a signal over time, or in other words: <i>modulating</i> the parameters. For an introductory example to modulation, consider how you would make a sine-wave tone fade in and out over time. One way is to multiply the tone by a <i>much</i> slower sine wave:</p>
                <div class="flex justify-center">
                    <div id="LFODesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>
                <p>The slow sine wave is an LFO (Low Frequency Oscillator) that modulates the amplitude of the fast sine wave. The fast sine wave is producing the actual tone, while the slow sine wave is controlling the amplitude. <a href=".?code=DYUwLgBMBmD2EF4IGcCWA7AFGVBbEAVAEwEAKAkgJQBQokYs6IiKG2ehJFBALDwAw1qAJ3ABXYeihwCDJkA%3D">Here</a> is this concept in action. If you return only the LFO or only the tone, you can see how each respective signal behaves on its own in the time domain. It's worth noting that the LFO is oscillating between -1 and 1, so the phase of the tone is reversed on every cycle. You can fix this by keeping the LFO's value between 0 and 1 (<a href=".?code=DYUwLgBMBmD2EF4IGcCWA7AFGVBbEAVAEwEAKAkgJQHEBQokYs6IiKG2ehJFBALHwAMlWrQBO4AK5j0UOASYsgA%3D">squaring the value of the LFO is one way to do this</a>). Another useful way to modulate a signal is in a more saw-like approach where an LFO starts at one value and follows a linear path to a second value. This can be done in javascript by <a href=".?code=DYUwLgBCB2BuEF4IEYIFoIAowEsC2IEApCgJQBQokA7gIayFIDOO0mATAFQAKAkpwBYBABk64CFAE7gArpOhQ4EThDoMgA%3D%3D">using the modulo operator with a time variable.</a></p>
            </div>
        </div>
        
    </div>

    <p id="shared-msg" style="display:none;" class="text-center dark:text-white"><b>Playground's Code Was Supplied By URL!</b></p>

    <!--CUSTOM EDITOR DROPDOWN-->
    <div class="dropdown root-dropdown" id="playground-dropdown">
        <h3 class="section-title">&#8594; <b>PLAYGROUND</b></h3>
        <div class="section-body">
            <div class="flex mt-2">
                <div id="editor" class="w-1/2 h-80"></div>
                <div class="w-1/2 h-80">
                    <div style="height: 10%;" class="w-full text-center bg-gray-200 dark:bg-zinc-900 dark:text-white shadow-sm text-xl">
                        Time Domain
                    </div>
                    <canvas style="height: 40%" id="playgroundOsc" class="w-full" width="1560" height="256"></canvas>
                    <div style="height: 10%;" class="w-full text-center bg-gray-200 dark:bg-zinc-900 dark:text-white  text-xl">
                        Frequency Domain
                    </div>
                    <canvas style="height: 40%" id="playgroundFFT" class="w-full" width="1560" height="256"></canvas>
                </div>
            </div>
            <button onclick="runUserCode(false)" class="button-colors rounded-md px-2 py-1 mb-2">Run</button>
            <button onclick="runUserCode(true)" class="button-colors rounded-md px-2 py-1 mb-2" title="Save the code for your next visit to this site">Run + Save</button>
            <button onclick="closeDSP()" class="button-colors rounded-md px-2 py-1 mb-2">Stop</button>
            <button onclick="shareUserCode()" class="button-colors rounded-md px-2 py-1 mb-2">Share</button>
            <p id="editor-err" class="text-red-700 dark:text-red-300"></p>
            <p>Volume:</p>
            <input id="vol-slider" oninput="dspSetVolume(this.value/100)" type="range" min="0" max="100" value="100">
            <div class="dropdown child-dropdown">
                <h3 class="section-title">&#8594; How This Works</h3>
                <p>The code in this editor is executed in a function that is called for every processed sample; you just have to return a number for each sample.</p>
                <br />
                <h3><b>Things You Can Use (on top of things already supplied by Javascript):</b></h3>
                <br />
                <ul>
                    <li><b>Variables</b></li>
                    <ul>
                        <li>time <i>(seconds)</i></li>
                        <li>sampleRate <i>(samples per second)</i></li>
                        <li>sampleNumber <i>(number of samples since beginning)</i></li>
                        <li>PI <i>(3.141592...)</i></li>
                        <li>global <i>(An empty JS object to store data that's persistent across samples. <a href=".?code=OYGw9gRghiDKCmAXAFAIjAV0agNAAgDoBmASjwHpz4BLRAC3gCc8B3WuvUSGBRAKD6UA8gCU8AWygA7DDBABPPtQBmyAITIA5GHpMA%2BpkSa81KZ3DQ4SEiQDefPI%2FPcQBHQ0YGseALyEiDk5clgT01IwAJl6Ivv4U5GEAzqzUICB4EPAmUrTUMNQAXvAReGBSAMZZUMks8Gl8AL4CjEgYjGbBMG5YQA%3D">Here</a> is a link showing how you can use it.)</i></li>
                    </ul>
                    <br />
                    <li><b>Functions</b></li>
                    <ul>
                        <li>sin(n), cos(n), tan(n) <i>(The trig functions for sine, cosine, and tangent)</i></li>
                        <li>pow(a, b) <i>(Raises a to the power of b, and returns the result)</i></li>
                        <li>min(a, b, ...), max(a, b, ...) <i>(functions that return the lowest and highest values of what you pass into it)</i></li>
                        <li>round(n) <i>(rounds n to the nearest integer)</i></li>
                        <li>floor(n), ceil(n) <i>(functions that round down and round up floating point numbers respectively)</i></li>
                        <li>abs(n) <i>(Take the absolute value of a number)</i></li>
                        <li>globalSet(variable, value) <i>(Initialize a persistent variable with a value. Variable name has to be passed in as a string!)</i></li>
                        <li>lerp(a, b, t) <i>(Linear interpolation between a and b with ratio t between 0 and 1)</i></li>
                        <li>clamp(value, low, high) <i>(return value or the lower/upper limit if value is outside of the bounds)</i></li>
                        <li>rand() <i>(Random value between -1 and 1)</i></li>
                    </ul>
                </ul>
            </div>
        </div>
    </div>

    <!-- I don't think we'll be needing this
    <div class="text-center">
        <h6 class="mt-2">interactive demo (WIP)</h6>
        <button onclick="onTestButtonClicked()" class="bg-slate-200 hover:bg-yellow-100 rounded-md px-2 py-1 mb-2">Run Demo</button>
    </div>
    -->
    

    <!-- PLAN (so far)...
        PROGRAMMING: sine waves & other waves
        user has task to make a sine wave, specifics tbd (but include some basics about pitch and multiplying the input)??
        user can try adding multiple sine waves.

        Another common type of wave: saw wave
        first user makes saw wave via mod func,
        then user does the same via adding sine waves according to the fact that each harmonic in a saw wave is sin(nx)/n.

        Same with square waves
        user can try subtracting a saw wave one octave higher from the original saw wave
        OR can add the harmonics manually

        TODO:
        noise and (its colors)
        filtering
        modulation of signals (pitch and vol LFOs and FM/AM/PM synthesis)
        Basic programmatic sequencing
    -->

    <!--<script src="js/main.js"></script>-->
    <script src="js/dsp.js"></script>
    <script src="js/scopes.js"></script>

    <!--Dropdown script-->
    <script>
    //NOTE: it could be convenient to cache the status of which dropdowns are visible for future visits
    function toggleDropdown(e) {
        // Flip visibility of children
        Array.from(e.children).forEach((c,i) => {
            if(i===0) return
            if(c.dropdown_originalDisplay === undefined) c.dropdown_originalDisplay = c.style.display //janky?
            c.style.display = c.style.display === 'none' ? c.dropdown_originalDisplay : 'none'
        })
        // Change dropdown arrow
        e.isOpen = !e.isOpen
        if (e.classList.contains('dropdown')) {     
            if(e.isOpen) {
                e.querySelector('.section-title').innerHTML = e.querySelector('.section-title').innerHTML.replace('→', '↓')
            } else {
                e.querySelector('.section-title').innerHTML = e.querySelector('.section-title').innerHTML.replace('↓', '→')
            }
        }
    }

    var toggleEverythingDropped = false;
    function toggleEverything(eBtn){
        Array.from(document.getElementsByClassName("dropdown")).forEach(e => {
            Array.from(e.children).forEach((c,i) => {
                if(i===0) return
                 c.style.display = toggleEverythingDropped ? 'none' : c.dropdown_originalDisplay
            })
        })
        toggleEverythingDropped = !toggleEverythingDropped
        // Change all arrows
        if (toggleEverythingDropped) {
            Array.from(document.getElementsByClassName("dropdown")).forEach(e => {
                e.isOpen = true;
                e.querySelector('.section-title').innerHTML = e.querySelector('.section-title').innerHTML.replace('→', '↓')
            })
        } else {
            Array.from(document.getElementsByClassName("dropdown")).forEach(e => {
                e.isOpen = false;
                e.querySelector('.section-title').innerHTML = e.querySelector('.section-title').innerHTML.replace('↓', '→')
            }) 
        }
        eBtn.innerHTML = toggleEverythingDropped ? 'Hide Everything' : 'Show Everything'
    }

    Array.from(document.getElementsByClassName("dropdown")).forEach(e => {
        e.getElementsByClassName('section-title')[0].onclick = () => toggleDropdown(e)
        e.isOpen = true;
        toggleDropdown(e)
    })
    </script>

    <!-- Manage shared or saved code BEFORE initializing the editor(b/c the editor takes a second to load) -->
    <script src="./js/lz-string.min.js" type="text/javascript" charset="utf-8"></script>
    <script>
    var code = (new URL(window.location)).searchParams.get('code')
        if(code !== null){
            document.getElementById('shared-msg').style.display = ''
            code = LZString.decompressFromBase64(decodeURIComponent(code))
            toggleDropdown(document.getElementById('playground-dropdown')) //slightly janky b/c toggle expects that all dropdowns are initially hidden
        }else
            code = (localStorage.getItem('code') === null) ? `//phasey saw!
let f = 110 //frequency
let v = 0 //output sample
let h = 50 //number of harmonics
for(let i = 1; i < h; i+=1)
    v += .15*sin(2*PI*i/50.0 + time)*sin(time*PI*f*i)/i
return v` : localStorage.getItem('code')
    </script>

    <!-- desmos stuff for some graphics -->
    <script src="https://www.desmos.com/api/v1.7/calculator.js?apiKey=dcb31709b452b1cf9dc26972add0fda6"></script>
    <script src="js/calculator.js"></script>

    <!--Editor stuff-->
    <script src="./js/ace/src-min/ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="./js/ace/src-min/theme-twilight.js" type="text/javascript" charset="utf-8"></script>
    <script src="./js/ace/src-min/mode-javascript.js" type="text/javascript" charset="utf-8"></script>
    <script>
        var editor = ace.edit("editor");
        var JavaScriptMode = ace.require("ace/mode/javascript").Mode;
        editor.session.setMode(new JavaScriptMode());
        editor.setValue(code)

        const fftCanvas = document.getElementById("playgroundFFT")
        const oscCanvas = document.getElementById("playgroundOsc")
        const oscCtx = oscCanvas.getContext("2d");
        const fftCtx = fftCanvas.getContext("2d");
        clearScopes(oscCanvas, fftCanvas, oscCtx, fftCtx)

        function runUserCode(save){
            setDSPsimple(editor.getValue())
            //also save it
            if(save)
                localStorage.setItem('code', editor.getValue())
        }

        function shareUserCode(){
            let codeURL = (new URL(window.location)).host + '?code=' + encodeURIComponent(LZString.compressToBase64(editor.getValue()))
            navigator.clipboard.writeText(codeURL).then(function() {
                alert('Link Copied to Clipboard!');
            }, function(err) {
                alert('Unable to Copy to Clipboard: ', err);
            });
        }
    </script>

    <!--Dark Mode Listener Script-->
    <script>
        function setThemeToPrefered(){
            let dark = localStorage.useDarkMode === 'true'
            if (dark) {
                document.documentElement.classList.add('dark')
                setCalculatorColorInversion(calculators, true);
                editor.setTheme("ace/theme/twilight");
            } else {
                document.documentElement.classList.remove('dark')
                setCalculatorColorInversion(calculators, false);
                editor.setTheme(0);
            }
            // Change scope color (clears canvas but thats not too big of a problem)
            scopeBGColor = dark ? scopeBGDarkColor : scopeBGLightColor
            scopeLineColor = dark ? scopeLineDarkColor : scopeLineLightColor
            clearScopes(oscCanvas, fftCanvas, oscCtx, fftCtx)

            document.getElementById('darkmode-btn').innerHTML = dark ? 'Use Light Mode' : 'Use Dark Mode'
        }
        // Set bg and scope line color initially
        const dt = window.matchMedia("(prefers-color-scheme: dark)");
        scopeBGColor = dt ? scopeBGDarkColor : scopeBGLightColor
        scopeLineColor = dt ? scopeLineDarkColor : scopeLineLightColor
        clearScopes(oscCanvas, fftCanvas, oscCtx, fftCtx)
        // Add dark mode listener
        dt.addListener(e => setThemeToPrefered(e.matches));
        if(!('useDarkMode' in localStorage)) localStorage.useDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
        setThemeToPrefered()

        function invertTheme(){
            localStorage.useDarkMode = localStorage.useDarkMode === 'true' ? false : true
            setThemeToPrefered()
        }
    </script>
</body>
</html>
