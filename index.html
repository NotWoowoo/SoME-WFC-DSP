<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="An Interactive DSP Guide">
    <meta name="og:image" content="img/cat-spin.gif">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="img/favicon/favicon-light.png" rel="icon" type="image/png" media="(prefers-color-scheme: light)"/>
    <link href="img/favicon/favicon-light.svg" rel="icon" type="image/svg+xml" media="(prefers-color-scheme: light)"/>
    <link href="img/favicon/favicon-dark.png" rel="icon" type="image/png" media="(prefers-color-scheme: dark)"/>
    <link href="img/favicon/favicon-dark.svg" rel="icon" type="image/svg+xml" media="(prefers-color-scheme: dark)"/>
    <link href="dist/main.css" rel="stylesheet">
    <title>Audio Programming Tutorial</title>
</head>
<body class="dark:bg-black">
    

    <div class="bg-slate-200 dark:bg-slate-800 dark:text-white py-2 shadow-sm"> 
        <h1 class="text-center text-3xl">DSP For Audio Programming</h1>
        <h3 class="text-center text-xl">An Interactive Guide by Sean McGoff and not_woowoo</h3>
    </div>
    

    <p class="text-center my-2" >
        <button onclick="toggleEverything(this)" class="button-colors rounded-md px-2 py-1 mx-1">Show Everything</button>
        <button id="darkmode-btn" onclick="invertTheme()" class="button-colors rounded-md px-2 py-1 mx-1"></button>
    </p>

    <!--ABOUT DROPDOWN-->
    <div class="dropdown root-dropdown">
        <h3 class="section-title">&#8594; <b>About</b></h3>
        <div class="section-body">
            <p>This website is designed to teach enough digital signal processing to start your journey into programming audio software. Whether you want to create VST plugins for digital audio workstations, add complex audio to your website/application/game, or just want to pick up a new skill, this free course will give you a great foundation in DSP.</p>
            <p>For those interested in what technology powers this site, we are using Github Pages to host the website, Tailwind CSS to style the pages, Desmos' API to create the interactive visualizations, and a slightly modified JS environment for the editor. The public GitHub repository can be found
            <a href="https://github.com/NotWoowoo/SoME-WFC-DSP" target="_blank" rel="noopener noreferrer">here</a>.</p>
        </div>
        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; How to use this website</h3>
            <div class="section-body">
                <p>This website is organized into a tree of dropdown menus, each expanding on subjects in higher level dropdowns (such as this "How to use this website" dropdown).</p>
                <p>To get the most out of this site, it's recommended to start by reading everything (with "Show Everything" if you prefer). Once you have gone through the information once, specific information is easily accessable by navigating the dropdowns.</p>
            </div>
        </div>
        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Prerequisite knowledge</h3>
            <div class="section-body">
                <p>While we aim to make this course beginner friendly, there are a couple of things that we recommend you learn before starting this course. The programming sections use Javascript as the language, so we recommend learning the fundamentals of programming and the Javascript language before trying the programming sections. As for the math in this course, it should be accessible to anyone who has taken a pre-calculus course or higher.</p>
            </div>
        </div>
    </div>

    <!--SECTION 1 DROPDOWN-->
    <div class="dropdown root-dropdown">
        <h3 class="section-title">&#8594; <b>Section 1:</b> What is digital audio, really?</h3>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; The Wide World of DSP</h3>
            <div class="section-body">
                <p>It seems pretty reasonable that to understand how to process digital audio, you must first understand what digital audio is. As you'll soon find out, digital audio is merely a category of a larger kind of digital data called signals. Signals are that new beat you spent all night working on, the readings from an EKG sensor, seismic data from geophones, and even images of cats on the internet! The point is that while this course is specifically geared towards digital audio, that is far from the only application of this course's material. If you want more information on DSP's applications in image processing and data compression, I'd recommend looking through Chapters 23 to 27 of <a href="http://www.dspguide.com/" target="_blank" rel="noopener noreferrer">Dr. Steven W. Smith's “The Scientist and Engineer's Guide to Digital Signal Processing”</a>
                </p> 
            </div>
        </div>
        
        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Analog vs Digital</h3>
            <div class="section-body">
                <p>What even is analog? Why does that older fellow in the music store keep insisting that his dusty old analog synthesizers sound so much warmer and natural than the modern digital trash? Does he even know what the word “analog” means? Since the D in DSP stands for “digital,” it only makes sense to start by explaining the difference. Before computers became the standard for audio processing, the main option for synthesizing and processing audio came in the form of dedicated electronic circuits. The sound waves in these circuits were represented through fluctuations of voltage over time. In other words, the fluctuations in voltage were an <i>analog</i> of the actual signal it represents (and that's why it's called "analog." The older meaning of the word "analog" is a noun and synonymous with words like "comparable" or "representation")! Since analog signals are represented by changes in energy, and physical levels of energy can't jump from one value to another in 0 units of time, the resulting signal is continuous. In other words, if you attached a polygraph machine to the source of an analog signal, and traced your finger across the resulting curve, you would never have to pick up your finger; the polygraph's position won't teleport from one position to another. To answer the question about the older fellow in the music store, there is some truth to his claim that analog synths can sound more natural. Electronic components like resistors and capacitors are prone to minor fluctuations in their current, voltage, and resistance. The result of this interference is noise which gives analog signals their characteristic warmth.</p>
                <div class="flex justify-center">
                    <img src="img/polygraph.jpeg">
                </div>
                <p>In comparison, digital signals are discrete. Rather than a continuous curve, the polygraph would show a set of evenly spaced points for a digital sound source. This method works well for computers as you can store a digital signal pretty efficiently on a hard drive, while you would need an infinite amount of storage space to store an analog one. Since computers store signals using lists of numbers that represent sound rather than the continuous voltage signals in analog circuits, digital signals don't suffer from the same noise interference that analog signals do. Since our application is audio programming, we will only focus on digital signals from now on.</p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Signals, Samples, Amplitude, and Sample Rate</h3>
            <div class="section-body">
                <p>So, what is this signal? A signal is a list of numbers over a fixed rate of time. In the case of audio, the numbers are known as the “samples” and they measure the “amplitude” at each sample's point in time. Typically, amplitude is denoted as a decimal value between -1 and 1. The way I like to think about amplitude is by imagining the cone of a speaker. An amplitude of 1 means the cone is pushed all the way out, and -1 is pulled all the way in. From the rapid movement of the cone's position over time, you get sound. The fixed rate of time is known as the “sample rate”, which is commonly measured in samples per second. The most common sample rate in music is 44.1khz, or 44,100 samples per second.</p>
                <div class="flex justify-center">
                    <div id="sampleRateDesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; <i>Try it Yourself</i>: Your First Waveform</h3>
            <div class="section-body">
                <p>We've been doing an awful lot of talking, so it's only fair now to let you do some programming. In addition to the lessons, we have included a playground where you can test out your audio programming skills, make cool sounds, and share your creations. This playground uses a slightly modified version of javascript, where the editor exists inside a function “processAudio” that expects a sample to be returned at the end of your code. Also, we have included aliases for multiple useful functions such as shortening Math.sin() to just sin().</p>
                <p>Without further ado, here's your first exercise. You might have noticed that for the examples, we have been using a sine wave. The filled-in code produces a sine wave, but a very slow one. You first want to speed that wave up so that it's audible (You can peek ahead to the frequency section if you get stuck). Next, try adjusting the amplitude of the wave (without adjusting the volume slider). Finally, try experimenting with adding sine waves of different speeds and amplitudes together. You can start the exercise <a href=".?code=PTAEGEAsEMBtYKYDsDmDQEYBcoDKAHBBAE1ABdIBLAZ1GsqXQHdoA3dAV3zoHtQBPHh1ABjaElCQE0AE6hKZAIQAoEBBjxkaUACYcAFQ4yJFdPUagW7UMR5MJACiYLIQsuSEiqqclNCseWA4AWzNYSmIEGQBKVTAoOERUdABmHABRAA9CGUpQpHdnClBgjlgySnxEOgZmNgRaaGJI0jIeNFMZZRkEMiMJcwcK0OigA%3D%3D" target="_blank" rel="noopener noreferrer">here</a>.</p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Bit Depth and the "Retro" Sound</h3>
            <div class="section-body">
                <p>Computers, and especially older ones, have a hard time accurately storing non-whole numbers. Since a digital audio signal's values are non-whole numbers by nature, that creates a limitation on how precise each value can be. In DSP, this precision is known as the “Bit Depth” of a digital signal. The bit depth is merely the amount of bits required to hold said number (<a href="https://web.stanford.edu/class/cs101/bits-bytes.html" target="_blank" rel="noopener noreferrer">Here</a> is a good resource to understanding bits and binary numbers). Most modern digital audio workstations use a standard bit depth of 32 bits, meaning that there are 2<sup>32</sup> possible values a sample can have between -1 and 1. Converting to lower bit depths forces samples' amplitudes to be quantized (snapped to the closest intermediate value). The effect of this is a noisier audio signal that sounds characteristically "retro" (since old hardware had lower bit depths).</p>
                <div class="flex justify-center">
                    <div id="bitDepthDesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; <i>Try It Yourself</i>: Your First Effects</h3>
            <div class="section-body">
                <p>Let's put that knowledge of bit depth to good use now. For your first audio effect, you will be building a <b>downsampler</b>. A downsampler, also known as a decimator, takes an audio signal of one sample rate and plays it as if it was another lower sample rate. For example, if you want to halve the sample rate, you can output a variable that only updates for every other sample. To cut the sample rate by a third, you would only update the variable for every third sample, and so on. This has the effect of creating buzzing high-pitched artifacts in the sound (you can hear this effect in songs like <a href="https://www.youtube.com/watch?v=2oIAQSUt9mo" target="_blank" rel="noopener noreferrer">Edge by Rezz</a>). In the starter code, we have defined a persistent output variable (global.output), a sine wave input (input), and a parameter for the intensity of the downsampling (b). The output variable is persistent (by being in the global object), because all other variable declarations/definitions are executed for every sample and can't persist across multiple samples. Your job is to edit the program such that the output updates every b-th sample. (hint: what does a percent sign do in javascript?)
                <br />
                <a href=".?code=OYGw9gRghiDKCmAXAFAcjAV0QBy6gNAAQAMAlIQPQVQDGN8Azg4QG4CWUhokMAdJjiwAoEEkJsAdrkSEAvIQaTkAJgBUABQCSqxGwC28VcuVkhIsRDmEAjMTNVCAYQAWMURODwAXIQzYAJlCI8Fzg0CD8WNKEAGZgAE6EYBIgAJ6E8Czw8ekQALSIzgpQetiiSTHiUsIOAHIA8gAqAKI%2BqZioICCEEvDw%2FoSIYL4MIYUhAEQMJWXwtRh6ENkTrFDxHBCivEIOAJqYhDRQEknY8CfjhBMAEmAA7oSNzmzMAOoJANYMK%2F7xYAH3E5xRJ6BIhfpsIaJSTAvRBNjJMzxJAYeInbjhSKCRBAA" target="_blank" rel="noopener noreferrer">Downsampler Starter Code</a>
                <br />
                <a href=".?code=OYGw9gRghiDKCmAXAFAcjAV0QBy6gNAAQAMAlIQPQVQDGN8Azg4QG4CWUhokMAdJjiwAoEEkJsAdrkSEAvIQaTkAJgBUABQCSqxGwC28VcuVkhIsRDmEAjMTNVCsMCCxswEoWwBmyBlD3YogByGHoQ8ABOhACkhJayCSSkQoSpXODQIPxY0laS0mYRSBgREuk8WQLSQA" target="_blank" rel="noopener noreferrer">Downsampler Solution Code</a>
                </p>
                <br />
                <p>If you're up for a bit of a harder challenge, you can try building a <b>bitcrusher</b>. A bitcrusher is a common effect that takes a signal with a high bit depth and “crushes” it down to a lower bit depth by rounding the samples to the nearest evenly spaced value. For example, if the bit depth was set to 2, the values that the wave will snap to are -1, -0.5, 0.5, and 1. For a bit depth of 3, it would be -1, -0.75, -0.5, -0.25, …, 0.75, 1. In the starter code, you are given two variables: a sine wave signal (wave) and a bit depth (b). Your goal is to quantize the signal into 2b evenly spaced values between 0 and 1. (Hint: using the round() function could be useful if you could change the range of the wave to make it work).
                <br />
                <a href=".?code=DYUwLgBA7ghgbiCBeCBnAlgOwBQCYIBUEACgJKEQAslADBWOgLYgCUAUKJAEbIS5tsA9IIDCACxjBQmAOYgAXBADKmGAAcIYMYjiSAriFQQA9gDNN26PERhjEHiASZgATzRqYAYxAATCLuADIy5wKBAQTAgAWgBGCBhMPxiAOjYAJ3A9NMjYBDYgA%3D%3D%3D" target="_blank" rel="noopener noreferrer">Bitcrusher Starter Code</a>
                <br />
                <a href=".?code=DYUwLgBA7ghgbiCBeCBnAlgOwBQCYIBUEACgJKEQAslADBWOgLYgCUAUKJAEbIS5tsA9ETYBlAPbAArg3GYAXBC4BPCI3FwsAcwhgAFogBOMTFsQAzQ%2BMYQ6YcX10Gl%2BiAAdxUEIbVYpqCABGABoIKylMABNtCDZ7J0RMEBhDEFRILDAQM0NQk0iEzDUNGP0jEzMlGABjAGtdB2wAWhCgllCvCGqTNEwYNzYQBENVOBhpRHieoZBMYFVUNxqQArGJpXAvWYgWiHyggDo2AkEBQUEIABU9dADbvYh%2FEHMpYAgxw3QYLlAGiD14CAOOA1LwPFA8KEuCwdkEzhcALIaRCwBBhCqTRo0UKMdicCAAL284ku4lwXEYflQgV42BoBwArBRsKjEABqNowoiMeFhcQRArxJIpNIZTBZHJsIlWUnkymYfw0lDhKLYaUkskUqmBdhCRHI6CA9GmRBcGr1eLNVo6vZRMLgKSGTBsVJgR1FfBENXE2VahXUiAXXGwwJsIA%3D%3D" target="_blank" rel="noopener noreferrer">Bitcrusher Solution Code</a>
                </p>
            </div>
        </div>

    </div>


    <!--SECTION 2 DROPDOWN-->
    <div class="dropdown root-dropdown">
        <h3 class="section-title">&#8594; <b>Section 2:</b> Frequency</h3>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; What is Frequency?</h3>
            <div class="section-body">
                <p>Until now, we have only been looking at digital audio in the time domain (where time is the horizontal axis of the graph), but a great deal of information can be dissected from the frequency domain as well. To introduce frequency, let's think about this cat spinning on a record player.</p>
                <div class="flex justify-center">
                    <img src="img/cat-spin.gif">
                </div>
                <p>We can measure the “frequency” by finding how many times the cat makes a full rotation per unit time. The standard unit for frequency is the hertz (hz), or cycles/second. Since the cat is spinning on a 33 rpm (revolutions per minute) record, we can find the revolutions per second by dividing 33 by 60. Therefore, we can find that the cat is spinning at a frequency of 0.55 hz, or roughly one full rotation for every 1.8 seconds.</p>
                <p>The best equivalent to this spinning cat in the world of DSP is the sine wave. Much like the GIF of the cat, sine waves are periodic, or repeat infinitely in a very predictable manner. Because of this property, we can measure a sine wave's frequency in a similar way. The frequency of a sine wave is 1 divided by the “period” of the wave, a.k.a. the time it takes to complete one cycle.</p>
                <div class="flex justify-center">
                    <div id="frequencyDesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; What is Phase?</h3>
            <div class="section-body">
                <p>While frequency is the number of cycles per second, phase is the starting position of the cycle. Phase is measured in either degrees or radians depending on the context (in this section, we use degrees). Yet again, let's think about these <i>two</i> gifs of cats spinning on a record player.</p>
                <div class="flex justify-center overflow-hidden">
                    <img src="img/cat-spin-phase-1.gif">
                    <img src="img/cat-spin-phase-2.gif">
                </div>
                <p>Both cats are spinning at the same frequency, and both GIFs are 28 frames long, but what differentiates the two felines is their starting position on the first frame. Cat number one starts facing the camera, while cat number two starts by facing away from the camera. In DSP terms, we would say that these cats are “out of phase” with each other. Now, compare that to these cats below.</p>
                <div class="flex justify-center overflow-hidden">
                    <img src="img/cat-spin-phase-3.gif">
                    <img src="img/cat-spin-phase-3.gif">
                </div>
                <p>This time, the cats are “in phase” with each other because they start at the same point in their cycle around the record player. In the context of DSP, signals that are added together can either interfere constructively or destructively depending on each signal's respective phases. If you play around with the graph below, you'll see how the individual sine waves constructively interfere when they are at the same phase, and weaken the signal the more they differ. If you put one wave at 0 degrees, and the other at 180 degrees, the two waves cancel each other out completely (this phenomenon has the convenient name of “phase cancellation”).</p>
                <div class="flex justify-center">
                    <div id="phaseDesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Everything is Sine Waves!</h3>
            <div class="section-body">
                <p>While a sine wave's signal can be described as having a single frequency, most audio signals are not simple sine waves. For instance, take a look this signal which is the sum of <i>two</i> sine waves where the second has a higher frequency and lower amplitude than the first:</p>
                <br/>
                <div class="flex justify-center">
                    <img width=400 class="dark:invert" src="img/sine-sum.png">
                </div>
                <br/>
                <p>Instead of assigning this complicated signal a single frequency value, it can be thought of as having two coexisting frequencies. If you graph this signal in the frequency domain instead of the time domain, you can see two distinct peaks which represent the amplitude of each sine wave in the original signal.</p>
                <br/>
                <div class="flex justify-center">
                    <img width=400 class="dark:invert" src="img/sine-sum-fourier.png">
                </div>
                <br/>
                <p>The horizontal position of each peak represents the frequency of each sine wave (higher frequencies are further right than lower ones), and the height of each peak represents the amplitude of each sine wave (amplitude in this case is the value which each sine function is multiplied by). The various smaller peaks are just debris from the method used to convert this signal from the time domain to the frequency domain: <b>the Fourier Transform!</b> In the 1800s, French mathematician Joseph Fourier discovered that ANY signal can be decomposed into a sum of many (or few) sine waves with different amplitudes, frequencies, and phases. The first <i>wave</i> is known as the “DC component," and is a flat line that represents the average amplitude of the signal. Each succeeding sinusoidal wave has a frequency that is an integer multiple of the first wave after the DC component (DC can be thought of as having a frequency of 0 for convenience). In some cases, this sum can be infinite, but for digital signals, there is a finite limit (this idea will be explored when we talk about the Nyquist Sampling Theorem). As this is an introductory exploration into DSP, we aren't going to go into the details of how the Fourier Transform works specifically. If you are interested in that, 3blue1brown has a <a href="https://www.youtube.com/watch?v=spUNpyF58BY" target="_blank" rel="noopener noreferrer"> great video</a> on the <i>how</i> of Fourier.</p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; The Vocabulary of Frequency</h3>
            <div class="section-body">
                <p>As we briefly touched on in the previous section, a lot of language surrounding frequency and the frequency domain is abstracted from the actual concepts. The ideas of harmonics, pitch, and timbre are intimately tied with the idea of frequency, even if the hobbyist musician doesn't necessarily think of them in this way. For example, if you ever hear a musician talking about “harmonics”, they are merely talking about what you know as the frequency components of a sound. For any given sound, there is a “fundamental” harmonic/frequency, which is the lowest frequency of a sound, and then its “overtones”, or subsequent harmonics above the fundamental. The “pitch” of a sound is determined by the frequency of the fundamental, while the timbre (a fancy french word for the <i>sound</i> of a sound) is determined by the overtones. In the example below, you can add overtones to a fundamental sine wave and watch the signal morph into what is called a “square wave”, which is a signal that periodically alternates between a positive and negative value, such that the signal is positive 50% of the time and negative the other 50% of the time.</p>
                <div class="flex justify-center">
                    <div id="squareDesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>
                <p>Below is a similar example, but this time, the harmonics added turn the fundamental sine wave into a “sawtooth wave”, which is given its name by how it looks like the teeth of a saw blade.</p>
                <div class="flex justify-center">
                    <div id="sawtoothDesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>
                <p>So what makes these signals look different? In the case of the sawtooth wave, the overtones are added at every integer multiple of the fundamental frequency, at an amplitude of 1 divided by the number of the harmonic (the first overtone will be half as strong as the fundamental, the second will be one third, and so on). For the square wave, only the harmonics with a frequency with an odd multiple of the fundamental are added. For more complicated sounds, such as guitars and pianos, these harmonics will be much less orderly than basic shapes such as square and sawtooth waves, and are subject to change over time. For example, the start of a piano has a lot of high-frequency content as the mallet hits the string, but over time, those higher harmonics are dampened out.</p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Nyquist Sampling Theorem and Aliasing</h3>
            <div class="section-body">
                <p>The Nyquist Sampling Theorem connects two of the concepts that we touched on previously: sample rate, and frequency. One of the main limitations of digital audio is the fact that it can only be precise to a finite amount. We explored this idea in the section about bit depth by talking about how lower bit depths quantize a digital signal, but there exists another form of digital information loss known as <i>aliasing</i>. When digitally sampling an analog signal, the highest frequency that a system can accurately store is equal to one half of the sampling rate of the system. This frequency is known as the “nyquist frequency”. This theorem is one of the main reasons why the most common sampling rate for digitally storing music is 44.1khz. Humans can only hear sounds up to about 20khz, which is close to half of 44.1khz (with a bit more room for good measure). When a wave containing frequencies higher than a sampler's nyquist frequency is sampled, aliasing occurs, where extra frequency content is introduced. By interacting with the graph below, you can see the effects that sampling a sine wave at different frequencies and sample rates has. The two sliders are scaled such that when they are lined up, the sine wave will be at the sampling rate's corresponding nyquist frequency. Pushing the frequency slider to the right of the sample rate slider shows the effects of aliasing, where the samples collected incorrectly introduce a sine wave that didn't exist in the source signal. </p>
                <div class="flex justify-center">
                    <div id="nyquistDesmosCalc" class="calculator" style="width: 800px; height: 500px;"></div>
                </div>    
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; <i>Try it Yourself</i>: Basic Shapes</h3>
            <p>Now that we understand how frequencies work, we can now make basic shapes other than sine waves using a process known as <i>Additive Synthesis</i>. Additive Synthesis is merely the process of creating sounds using the sum of sine waves at different frequencies, phases, and amplitudes. In the starter code, we are using a for loop to create a sawtooth wave, where each harmonic is at an amplitude of 1 divided by the harmonic number. Your first challenge is to make this code produce a square wave. If you remember from the “Vocabulary of Frequency” section, a square wave contains only odd-numbered harmonics. If you feel good about that, try producing a triangle wave. Like square waves, triangle waves only contain odd harmonics. What differs is that the phase of each harmonic is a 180-degree turn from the previous harmonic (which is equivalent to multiplying the wave by -1). Additionally, the amplitude of each harmonic dampens by 1 over the harmonic number squared (or the harmonic number to the -2nd power). In this exercise, we have also included possible solutions for each challenge with comments explaining how they work.</p>
            <ul>
                <li><a href=".?code=PTDCAsEMBtoUwHYHM4AICMAuVBZSBrNAF3AEsBnVAYwHsATNABwCd6BXKtSVcgRzcjM0Ad0gA3OACgQAIRoI25bHkKoSFavSas6HLmualIyeKlETJ8IqgBmqALyoALE4AMqEDaH9EVAJ6WcNYIDqjuIDRsRIxRPJAAtozwgdbgoQCs4cAK8QBGcMyoNHZQzPHypFTkkjY0zAAUVqikoegA3M2oADyo4B2kANT26ACUqADekqjTqCFDqPXoHs1jAFQ8pAj1AEyo6wAKAJJ7tict60Sk8XBjkgC%2BkpJCRGzMIa4AdOknCEA%3D%3D%3D" target="_blank" rel="noopener noreferrer">Starter Code</a></li>
                <li><a href=".?code=PTAEGEAsEMBtYKYDsDmDQEZQGUD2sBXAFwEtckAoRI0AM1AF5QAWZgBioRqUdA%2BtCReAVg4hQJUElwB3UClwIAznQBOuALaYANKADMu4buhIAJqCW5Q5AHR2KtXKoAUAyUwwBuCaAA8g7xIAagYAJgBKUABvClA4qVAQ0GcsMBJIgCoLEiRnUNAsgAUASQK6Msks0g0ESIoAXwoKVS4CVR42G2EypCA%3D" target="_blank" rel="noopener noreferrer">Challenge 1 Solution</a></li>
                <li><a href=".?code=PTAECEHsDsFcGdQGEAWBDANhgptA5tqAMqQawAuAljAFA7mgBmoAvKACzsAMd2D0rUD3qgUggKw9GkAE4AKEZUEBGANyglAHlHrKAahbKAlKADeNUJdAhQAFRSVEAd0pZQAI0LkUhRjOwAjrC4AMYAnqAAtrAYVAAOGJTYMkyyoNhoIWLoMpEwlCEWViIoAHKwkYJyAEygAFQaJgC0oMpFljZxkE5yTcoANI1MiXGI3oRx6PCETg44oF09ZRWD1SYAJmiRcbhjPqBbCZTksOvY7aACBgvdvQNDDYtyy5GDTWv1oPCU0DWfAAoASU%2BzAaL0%2BVEi2BMNAAvjQaP4TjIBFwAHTiT7QIA%3D%3D%3D" target="_blank" rel="noopener noreferrer">Bonus Challenge Solution</a></li>
            </ul>
        </div>
    </div>

    <!--SECTION 3 DROPDOWN-->
    <div class="dropdown root-dropdown">
        <h3 class="section-title">&#8594; <b>Section 3:</b> Filters and Filter Analysis</h3>

        <p class="mt-2">Filters are any system that takes a single input signal (commonly denoted as x[n] in DSP-world), and returns a single output signal (denoted as y[n]).</p>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; LTI Systems</h3>
            <div class="section-body">
                <p>Before we jump into filters themselves, it would be best to explain a concept that dictates a lot of the things we will be able to do later. Pretty much everything that we assume in this section hinges on the condition that the filter is LTI. LTI stands for Linear (and) Time-Invariant, and is a set of rules about how a system can output based on an input (a system is a more general word for this concept, but we'll be looking at filters specifically). There are three rules in total: Additivity, Homogeneity (these two being bundled under the term “Linearity”), and Time Invariance. The additive property states that two signals passed through a filter and then added together is equivalent to those two signals added together first and then passed through the filter. If a filter does not have this property, it is not additive. The homogeneous property states that a change in an input signal's amplitude results in a corresponding change in amplitude in the output signal. For example, if you change the amplitude of an input signal into a homogenous filter to twice what it was before, the output will also be twice the amplitude. The last property, time invariance, states that if a system receives an input shifted in time by k samples, then the only change in the output will be a shift by k samples. If a filter has all 3 of these properties (or any one-input one-output system for that matter), it is LTI. Below are some examples of different filters, and whether they are LTI or not.</p>
                <ol class="mt-2">
                    <li><b>y[n] = 0.5*x[n]</b> ✅</li>
                    This filter is LTI
                    <li><b>y[n] = x[n] + 1</b> ✅</li>
                    This filter is LTI
                    <li><b>y[n] = sin(n)*x[n]</b> ❌</li>
                    This filter is not LTI because the amplitude is dictated by sin(n), which changes over time. This makes the filter not adhere to the rule of Time Invariance.
                    <li><b>y[n] = x[n-1]</b> ✅</li>
                    This filter is LTI
                    <li><b>y[n]  = x[n]<sup>2</sup></b> ❌</li>
                    This filter is not LTI because it does not adhere to Additivity or Homogeneity. The additivity rule breaks because if it were additive, (a + b)<sup>2</sup> would have to equal a<sup>2</sup> + b<sup>2</sup>, which we know is false. It also breaks the rule of homogeneity because a change in amplitude in the input results in a change of amplitude by a power of 2 in the output.
                </ol>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Moving Average Filter</h3>
            <div class="section-body">
                <p>To start our exploration of filters, we'll be studying the moving average filter. What a moving average filter does is store the past <b>n</b> samples of the input in an array, and then return the average of them. If you run the <a href=".?code=PTAEDtQXlBDAnesCeBlAlgLwKYCgA22ALhFAEwAMuuIoAkuOkerPltqAEYCuAZr9nhxEKXOl4AKAIQBzfAHtOrAHQ9eASgDeuULtBzFKtdAjYA7qACCI5BPDqde3vPgTCJdCYoBuUJ4A8EL7oANRQAIwOetH6Ckr4qnwA2ugAul64AL7UtABK2AC28gBuHLzo8ADOJNiEBdjgRAA0cAAmrRDy6JUclbAFAA6EcDXgrbgG8Ym8ypUAFuJEEg6TRnzKA9zzEkhjEgC04U2RDjRg%2BUTc8JCWpUgyePDEV5CrCWrKT63cAMbYEhJYE1OOooAA%2BWAhEGgMDgIA%3D%3D%3D" target="_blank" rel="noopener noreferrer">example here</a>, you'll see that this has the effect of smoothing out the input sound and taming the high-frequency content. If you play around with the value of <b>n</b>, you'll see that higher values of n results in less high-end, and more little notches in magnitude. Why is that? </p>
                <p>One really powerful way of analyzing filters is through response curves. The two common response curves in DSP are the impulse response and the frequency response. The impulse response shows how a filter responds in the time domain by graphing how a single impulse of amplitude 1 at time 0 behaves in a filter. This “impulse” has many names in DSP, such as the unit impulse function, the delta function, Dirac's delta function, δ[n], but the name we'll be using in this guide is the <b>unit impulse</b>. The frequency response curve shows how a unit impulse responds in the frequency domain (you can also think of the frequency response being the Fourier Transform of the Impulse Response if you'd like). For the moving average filter, this impulse response can be done pretty simply in your head. If you are taking the average of k samples at time 0, one of those samples has an amplitude of 1, and the rest are at 0, the average will just be 1 divided by k. Once the moving average buffer moves out of the range of that impulse at time 0 (or when time ≥ k), the average will just be 0.</p>
                <div class="flex justify-center">
                    <div id="MAFDesmosCalc" class="calculator" style="width: 800px; height: 400px;"></div>
                </div>
                <p>The frequency response curve, however, is a bit more complicated. The response can be graphed using this equation which is derived from taking the Fourier Transform of k<sup>-1</sup>:</p>
                <div class="flex justify-center">
                    <img class="dark:invert lg:w-1/3 md:w-1/2" src="img/moving-average-freq-response.png">
                </div>
                <p>The input variable, ω (omega), is the frequency as a fraction of the sampling rate. For example, if the frequency in hz is 20hz, and the sampling rate is 80hz, the corresponding ω value would be ¼. The k value here represents the buffer length of the moving average filter, and the output is the amplitude of a frequency ω passed through the moving average filter.</p>
            </div>
        </div>
        
        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; What is Convolution</h3>
            <div class="section-body">
                <p>Convolution, for lack of a better term, can be a pretty convoluted concept in DSP. Convolution is a binary operation. It takes in two signals, the input, and the kernel, and returns a singular output signal that blends the two signals together. Since this operation is commutative, there is really no difference mathematically which signal is the input and which is the kernel. However, the common convention in audio programming is to treat the input as the source to be filtered and the kernel as a parameter of said filter (more on why that is later). Here is the equation for the convolution of an input signal x[n] and kernel h[n] (the asterisk is the standard symbol for convolution):</p>
                <div class="flex justify-center">
                    <img class="dark:invert lg:w-1/3 md:w-5/6" src="img/convolution.png">
                </div>
                <p>In the convolution operation, the kernel is first flipped horizontally and then shifted by a horizontal offset <i>n</i>. The resulting output is the inner product of the input, and this flipped and shifted kernel (the inner product is when the samples at each index are multiplied together, and then all summed up).</p>
                <div class="flex justify-center">
                    <video width="600" height="400" controls>
                        <source src="video/Convolution.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                </div>
                <p>In the animation above, you can see the input wave in yellow being convoluted by the 3-point kernel in blue, resulting in the red output. This results in another sine wave of different phases and amplitudes. For inputs in kernels of different sizes, any place where the kernel or input is undefined is assumed to be 0, so in this case, the only 3 points that are multiplied and then added are the points where the kernel is. In the graph below, you can play around with the 3 points of the kernel, and see what the convolution will be.</p>
                <div class="flex justify-center">
                    <div id="convolutionDesmosCalc" class="calculator" style="width: 1000px; height: 500px;"></div>
                </div>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; <i>Why</i> is Convolution?</h3>
            <div class="section-body">
                <p>Convolution has a property that makes it amazingly useful when it comes to filter design and implementation. That property is that <b>any LTI system can be represented as a convolution operation</b>. To understand why this is, let's look at a special example of convolution. We are going to make the kernel of the convolution equation the unit impulse function:</p>
                <div class="flex justify-center">
                    <video width="600" height="400" controls>
                        <source src="video/IdentityConvolution.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                </div>
                <p>As you can see, using the unit impulse as the kernel does not change the input signal at all. In math, this is known as an <i>Identity</i>. Much like how multiplying a number by 1 or adding 0 doesn't change the number, convoluting a signal by the unit impulse doesn't change the signal. We can use this property to our advantage by decomposing our input signal into a sum of much smaller signals. For our purposes, we will decompose the signal into a sum of shifted and amplified unit impulses. Each sample in the time domain can be expressed in terms of a unit impulse that is shifted to the position of each sample, and then multiplied by the amplitude of that sample. In equation form, this decomposition looks like this (δ[n] being the unit impulse function and N being the length of the signal):</p>
                <div class="flex justify-center">
                    <img class="dark:invert lg:w-1/2 md:w-full my-2" src="img/impulse-decomposition.png">
                </div>
                <p>Since we know how a unit impulse responds through any given filter through its impulse response, we can now replace δ[n] with our impulse response. We are able to do this because the response will be the same regardless of if we add the impulses or filter them first (additivity), adjust the amplitude of the impulse (homogeneity), or shift the signals in the time domain (time invariance):</p>
                <div class="flex justify-center">
                    <img class="dark:invert lg:w-1/2 md:w-full my-2" src="img/impulse-response-decomposition.png">
                </div>
                <p>In the equation above, H is our filter and δ<sub>h</sub>[n] is the impulse response of filter H. Finally, we can rewrite the right-hand side as a summation equation:</p>
                <div class="flex justify-center">
                    <img class="dark:invert lg:w-1/3 md:w-5/6 my-2" src="img/impulse-response-convolution.png">
                </div>
                <p>Look familiar? Yup. It's the convolution equation. What this tells us is that putting a signal through an LTI filter is an equivalent operation to convolving the signal with the filter's impulse response. This also has the implication that all information about a filter can be stored in just an impulse response. If you take a look at the frequency response of the unit impulse, this should make intuitive sense why:</p>
                <div class="flex my-2 px-2">
                    <img class="dark:invert w-1/3" src="img/delta/time-domain.png">
                    <img class="dark:invert w-2/3" src="img/delta/frequency-domain.png">
                </div>
                <p>The unit impulse signal contains <b>all frequencies</b> at the same magnitude of 1, with no deviations in phase. This means that when a unit impulse is run through a filter, the output represents how <b>any signal</b>  will change in the filter because the unit impulse's response contains information about the response of <b>every frequency</b>.</p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; The Window Sinc Method</h3>
            <div class="section-body">
                <p>While the moving average filter is simple, it isn't too great in separating content by frequency as it leaves those little notches in the frequency domain. Ideally, what we want is a “brick-wall filter”, where every frequency above a cutoff frequency is completely cut out. In the graph below, you'll see what this ideal frequency response looks like, and how the corresponding impulse response looks as well.</p>
                <div class="flex justify-center">
                    <div id="brickwallDesmosCalc" class="calculator" style="width: 1000px; height: 500px;"></div>
                </div>
                <p>This impulse response can be calculated by taking the Inverse Fourier Transform of the frequency response curve. The general equation for this type of response is:</p>
                <div class="flex justify-center">
                    <img class="dark:invert lg:w-1/6 md:w-1/4 my-2" src="img/sinc-function.png">
                </div>
                <p>where f<sub>c</sub> is the cutoff frequency as a fraction of the sample rate. This function shows up so frequently in DSP that it has been given its own special name - the <b>sinc function</b>.</p>
                <br>
                <p>Using what we learned in our lesson on convolution, we should just be able to plug in the sinc function as our kernel and we have our filter, right? Well, there's a slight problem with that. The sinc function goes on forever in both directions, meaning that to convolve a signal with the sinc function, we would need to multiply an infinite number of times for every sample. To get around this, we need to “window” the function, which restricts the domain of the function in order to make it finite. The simplest window function is a rectangular window, which sets all samples more than M samples away from t=0 to 0. You can see how this works in practice with <a href=".?code=PTBKFMGMBcEMDsDmBXANrATgAgMoEt5IsAzPVacDAKFXGhKIF4sAGAOgCYsQtJloA9sWIkM4AI7JwhAJ406WALJZmAFhbdgWAM6CADgCMEAE3n0AbitaaB%2FPfx2wAtntpV3PAMJjY0AoiwAa0p4cFQqPGIACgBCRFQBI1Q2YIxQ1ABKLABvKix8zSwAaRCwrG9wXzwBeCwAMWRCPxq8gsga3V5YVEgStLLmEkaYavgogA8s3IKZrDFoZDSscawY5g0Afh0CKK4AKnyABQBJLAPiIgPJ7iwok7PlrIAuLH2GVvyAXw%2FCurJULCYDCwGRYADueGgAAsgqVwjN4oluik4VZQmCsABBDDAmRRRQZH7EAQYKK0eh4KwsADcWEpAB4lLTKQBqZgARkJswKiKSKP6qAA2ngALpWSDdXpwqJ4QnfKg8Y7wez0ABCyGElAi0TiCT5Bg1Ux%2BvORBpEzHRWJxIPxXIKxNJ5LpVOZWEZimZbM5PwRetNGuFYvWVHlPExxmMWHgAjw2nAWEEWDNxC1JuSZrY2ihkWgUUJabYGfsWaiwPgxiiAFp2QAaTmEhVaTw1cwCVDmcBUB1khSU9au92utlYTk5H6WYcFs2C5SVkdYOeih4F1LpQMh9zzRa1cxAA%3D">this code</a> (try messing with the cutoff variable, fc, and the stopband variable, M).</p>
                <div class="flex my-2 px-2">
                    <img class="dark:invert w-1/3" src="img/windows/rectangular/impulse-response.png">
                    <img class="dark:invert w-2/3" src="img/windows/rectangular/freq-response.png">
                </div>
                <p>While this does work, the frequency response contains a huge boost before rolling off, and the phase is nearly inverted at that cutoff as well. This can be attributed to the very sudden snap to a horizontal line of 0 amplitude at t = M on. What we'll try next is what's known as the “hamming window”. Unlike the rectangular window, the hamming window eases the signal to 0 rather than snap it after a certain point. Here's the equation for the hamming window:</p>
                <div class="flex justify-center">
                    <img class="dark:invert lg:w-1/3 md:w-1/2 my-2" src="img/windows/hamming/equation.png">
                </div>
                <p>In the graph below, you can play with the cutoff frequency and stopband (M) to see the corresponding hamming window, and in <a href=".?code=PTASEMFtISwOwOYAIDq8AmB7A7kgyvAMZIBmMANgC4CmATgFDnWWnEC8SADAHQCMSIJIQCulTCRKla1AI7DqcQgE9GzJAFkkHAEycBwJAGcxABwBG4OOlUsAblq77Mok6KNQTTet8EBhaeCU8MgA1nRw1OT0MCQAFACECOSYFuTcYbQR5ACUSADe9EhF%2BkgA0uGRSL7g5CLkgTCYcEgAYsKKQU2FxYRNxkI1hOWZlRyk7YSdcLEAHrkFxYtITCyGRA4zSPEcegD8RvCx2kgAVEUACgCSp6w3cwJIsVd3uQBcSMdnJITdS8tqAAsoLBEA4eABWAAsSAAtI8eJCAGwnXqGI4nK4nTYGWKaOG8bKE35LaSUYSZJBA6DBG5rRTEgC%2BxMELQo5CQ4FotHASiQ2BglABSAyWWJSRSNXSFXZHAiuAAglyebjssSSJhaLEVkgYGCANw6pAAHg0Bt1AGoOATiYtxakpSNyABtGAAXQchEGwyysRgqqZ9EElzgrhYACFhBI6NE4olkvazJH5mL45LE5JZdQFUqlCq1RqtWpdTszcbTTrLda%2FkU7WnIy73Tt6AHBPL0OgkHBMDBDNQkGIkOmSNHa2l09xDACYpRYqrR9xx65J7FuVZYjDeAAaAmqwMGXxNWyYci2aj0dWa7XFrilk3qUuWpAE%2FLE%2ByP%2Bfpp14p%2BwnXus7ziKkQNs23ikuSzS2EAA%3D%3D%3D">this code here</a>, you can hear how different cutoffs and stopband values filter a white noise signal.</p>
                <div class="flex justify-center">
                    <div id="hammingDesmosCalc" class="calculator" style="width: 1000px; height: 500px;"></div>
                </div>
                <p>While this window does give more control over the speed of the roll-off through the stopband value, there is a pretty apparent resonance that forms at the cutoff frequency. The phase response isn't great either, with both a huge divot and a peak at the cutoff frequency.</p>
                <div class="flex my-2 px-2">
                    <img class="dark:invert w-1/3" src="img/windows/hamming/impulse-response.png">
                    <img class="dark:invert w-2/3" src="img/windows/hamming/freq-response.png">
                </div>
                <p>So, what is the magic solution? Well, there really isn't one for this method. Every window has its own offshoots, roll-offs, and ripples that make them unique. Fortunately, in the context of audio programming, this is ok! There are times when you might <i>want</i> that resonating frequency at the cutoff frequency of a hamming window or the roll-off of a rectangular window. The joy of audio programming is that it's one of the more creative applications of math and programming, so why not play around a little?</p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; <i>Try it Yourself</i>: One more Window</h3>
            <p>For this challenge, you're going to take the example code from the Hamming Window, and use it to make a filter using the <i>Blackman Window</i>. The equation for the Blackman Window is this:</p>
            <div class="flex justify-center">
                <img class="dark:invert lg:w-1/3 md:w-1/2 my-2" src="img/windows/blackman/equation.png">
            </div>
            <ul>
                <li><a href=".?code=PTDCAsEMBtoUwHYHM4C4AEoD2CBucAnAF3SPAEsBndKAW1vOXQHdGATLZ9AM3OiMLpGRLOkjoAQtEgBjANa1ICdAHV2ndADE%2BAggCh4JbjPQBedAAYAdAEZ0IdDICuI7tx4E4ARyeIZATwM4EgBZM3QAJgt7YHRKEQAHACMlNiCSXHDokCwXBJc4yFoE%2BD0yh1BPSCJGJHQ5QgQ4aD1ybgAKAEIkaCwU6CsGgiboAEp0AG89dBmY9ABpRubMGGdpGpwtJwQZDYRp2ZkceMdVxeHl8x5t3fIcdoAPcanZ1%2FRDOMYTcwf0TvNogB%2BT4IdoRdAAKhmAAUAJKQngmKFPezodpwhEojDgqHGA5vGLgei0Kyk0n4t4fOgMJgAqwAVgALOgALRo6yMgBsEKOlDBELhEN%2BsXaYTZNlGkopr08RCcwxoRRpdShlC%2BFIAvhSHNpYGICARIP4WOQyPUli1Xj0%2BjBBhbwk0uABBA1G0WjCncLAEdofchZADcQnQAB50CEg%2F6ANTmCXS2bW%2Fp2i7QADa5AAuuEZGcLe1yB6tXoHLCEPkSBInG5CK0Ot1ekmklXnhTE7am%2B5zI70C7Df53Z7vb7gsGAZHQ%2BHIzG4wSZm2Bh301mAXoiw4nWw2OgEFgqHBSKIO9wa%2FOrB2rJQKNwiO0Pafz%2FlL%2B1DQg2O0WTYADQSj3F2LYPAsGgfA9C9H0%2FUDYMwwjYMY3QCVJgpTI4PvKtUzFeDWSELMoVPIYRiXVcylleVlFwIA%3D">Starter Code</a></li>
                <li><a href=".?code=PTBCBsEMGMGsFtIDsAEB1AlkgJgewO4oDKu4ArgC4a6oDCu2ApgFDiMUoBm0KAvCgAYAdAEYUIFNEq5OnLgCdGARzKMk0AJ6t2KALJ8UAJgHjgKAM4VcABwBGybNo4A3AyZC5K1yhcjxrbMxBErSKkFRIAOYosIzySIzgzBicABQAhJHguPbgQrHxiQCUKADezCiVpigA0nEJ4Ci0kOBSUFQ0KABiZOodSBVV0DSWki3QdYWN%2FFy90P2pAB4l5VVrKGwc5lg8%2FIso6fwmAPwWWKmGKABUlQAKAJLXXDw3y%2BIoqQ9PbwBcRk%2FcQbraoAKTIo2GSGccQ4FAAFowUIh4ShlGRwtRUFYUNYNPCaED1psULYoHBEKgjkIAKwAFhQAFoPsJqU9huZUhcnl9XiUzLoiiUANTMoQCAAcV3ZnPpNx5KDe%2FMFhLWigoZHiJLJCGQT226kJAF9CRIuhhwI1IPJ5JANCh8BgUQUGoSsjkWvl6okDAlCABBa221ICwmcXDyVLEjBuADcKGjAB49HHo0L%2BCIiiqqm7cp6pgBtDAAXQM0HGkwaqQwmeNzAk9yQ3g4oDIsjiyTSmWyudsrZWru7Ht7cn4vpQAZtGmDmbWYYjUdj8ZQSd0KbTGazlRzQ9bhZLR2YtYkfuw2BQSFwGHMiOxw847e3eWHQnMcJSFFSmcfQmf3lfqRtHBUgZEQABoM0zOszHoKFSGhZg50jHRoyOFNl2TJc0xQDMykJVwsO%2FYd830JkxCZYsnm%2FZ1Ej3Q8gjVDVUGcIA">Challenge Solution</a></li>
            </ul>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Passing All the Things!</h3>
            <div class="section-body">
                <p>Up until now, all of the filters we have looked at were “low-pass” filters, where the frequencies allowed through are below the cutoff frequency. Now, we're going to use what we've learned previously to find a kernel for a highpass filter. To start, we'll use the window-sinc method for this exercise, only now, the ideal brick-wall frequency response is different. Instead of the amplitude being 1 above f<sub>c</sub>, the amplitude with be 1 <b>below</b> f<sub>c</sub>.</p>
                <div class="flex justify-center">
                    <img class="dark:invert lg:w-1/3 md:w-1/2 my-2" src="img/hp-brickwall-frequency-equation.png">
                </div>
                <p>So for this equation, what would the corresponding impulse response be? We can take advantage of the fact that the fourier transform (and its inverse) are linear systems, meaning they both follow rules of additivity and linearity. To start, we can think about how the frequency response of the brick-wall high pass in terms of its corresponding lowpass frequency response. If we look at the low-pass response's graph, we can see that if we can see that by multiplying by -1, and then adding 1, we get the high pass graph. More formally, we can write this equation:</p>
                <div class="flex justify-center">
                    <img class="dark:invert lg:w-1/3 md:w-1/2 my-2" src="img/hp-lp-brickwall-relationship.png">
                </div>
                <p>Now, since we want the impulse response from the frequency response, we'll want to take the inverse fourier transform on both sides, and since this operation is linear, we can rewrite the right side as two separate inverse fourier transforms (the homogeneous rule being applied by the -1 being multiplied by B<sub>lo</sub>(n), and the additive rule being applied by first taking the inverse fourier transforms and then adding the two terms):</p>
                <div class="flex justify-center">
                    <img class="dark:invert lg:w-1/3 md:w-1/2 my-2" src="img/inverse-ft-ideal-hp.png">
                </div>
                <p>As we discussed in our look into window sinc filter design, the inverse fourier transform of a lowpass brick-wall frequency response is the sinc function, but what's less obvious is what the inverse fourier transform of 1 is. If you remember the little intuition we gave at the end of the convolution section, you'll remember that the unit impulse has a magnitude of 1 at every frequency, or in other words, the fourier transform of the unit impulse is a horizontal line at 1. Therefore, the inverse fourier transform of 1 will just be the unit impulse. Finally, we can write the solution to the inverse fourier transform of the high-pass brick-wall frequency response at the unit impulse subtracted by the sinc function:</p>
                <div class="flex justify-center">
                    <img class="dark:invert lg:w-1/3 md:w-1/2 my-2" src="img/inverse-ft-hp-spectral-inverse.png">
                </div>
                <p>Luckily for us, subtracting the impulse response from the unit impulse is a general solution for finding the corresponding high-pass filter for any low-pass filter (for the ones we've looked at so far, at least). <a href=".?code=PTDqEsDsBMHsHcAEBlKBjRAJcBzAFgLQAKAhgM5mIBi4ANgC4CmATgFC2P2IBmGAvIgAMAOgBMiEIjQBXerG7cezRgEdpjSGgCe7TogCyiAaMETgiMnIAOAIxIxdXAG5GhZ2LKuyLJALZWOViDJAGFlEnooHEQAaxZIRlpWcG4ACgBCHFpYO1phOOYE2gBKRABvVkQqs0QAaXjExBCSWhlaCPBYSGppTUiuyuq0LsspFrR6wsaBHl60fshUgA9Siur1xA4uMnRXJcR0gVMAfgsoVPEAKiqiAElEa94HxBWJRFS759eALkQrnjQgw2mz0eD8viirhEAFYACyIAjvESwgBsl2GZAulzul325lShkRAEZiqSgRtJNBEvQSLM%2Bp1uhDINJKDtNHT5gzyestogoE4WGRGKh2QJ9nwjohTkSEWd2b8CDLrmzAcCqpJ4FA4JrINF6HhGHzIALmEK5RgoJZGCRoNzqsp6NJCogwb4mdFrvzBcL0OSAL7kyQ0Wi0RAkZjMEhaRCa%2FWxBpJdZZHItfIJ1wJJAAQQjUYJxXJ3FgzFSvPAUIA3HzEAAeAxV8sAagEJLtVWTuTTU1oAG1wABdVxocaTIqpcAFgOsSS3SBeLgAIWkChYyTSmWynZsy9W5I7qe3igEmcQOcjWnzheLpb05aODdr9b5zdbasQ%2B7yh77g6OrCnkizaBoEQSBYHAM05EQQ9uFXD9hEPYQyDwFJ6FSAs4IQrwkNSSMYFSRUABoSQLadzBCLonFgWgBVYIsSzLStqzrfQH2bRASXKckXDYjDlx7Ql2NlAdnjggoim%2FP8ggdJ1uicIA%3D%3D">Here is the code</a> for a high pass hamming window filter if you're interested in how the implementation looks.</p>
                <br>
                <p>High-pass filters are cool, but there are more than just the two. For instance, if you run a signal through a high-pass <i>and</i> a low-pass filter, you'll get a band-pass filter, which subdues frequencies outside a specific “band” between the high-pass cutoff frequency and low-pass cutoff frequency (assuming the high-pass cutoff is less than the low-pass cutoff). In fact, since convolution is an associative operation (the order in which you do successive convolutions doesn't matter), you can actually convolve the impulse responses of the high-pass and low-pass filter <i>first</i>, and then achieve the same effect with half of the multiplications required every sample. If instead, the high-pass cutoff is <i>higher</i> than the low-pass cutoff, you'll get a band-reject filter, where everything inside the band of frequencies between the cutoffs is subdued.</p>
            </div>
        </div>

    </div>

    <!--SECTION 4 DROPDOWN-->
    <div class="dropdown root-dropdown">
        <h3 class="section-title">&#8594; <b>Section 4:</b> Modulation, Making Music, and Miscellaneousness</h3>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Modulation and LFOs</h3>
            <div class="section-body">
                <p>As cool as the basic shapes might sound, they are, for lack of a better term, a little <i>basic</i>. Unless you're making music for a game on an atari 2600, you'll probably want more dynamic sounds than just square and sawtooth waves. One of the ways that you can escape the depths of monotony is through changing the parameters of a signal over time, or in other words: <i>modulating</i> the parameters. For an introductory example to modulation, consider how you would make a sine-wave tone fade in and out over time. One way is to multiply the tone by a <i>much</i> slower sine wave:</p>
                <div class="flex justify-center">
                    <div id="LFODesmosCalc" class="calculator" style="width: 600px; height: 400px;"></div>
                </div>
                <p>The slow sine wave is an LFO (Low Frequency Oscillator) that modulates the amplitude of the fast sine wave. The fast sine wave is producing the actual tone, while the slow sine wave is controlling the amplitude. <a href=".?code=DYUwLgBMBmD2EF4IGcCWA7AFGVBbEAVAEwEAKAkgJQBQokYs6IiKG2ehJFBALDwAw1qAJ3ABXYeihwCDJkA%3D" target="_blank" rel="noopener noreferrer">Here</a> is this concept in action. If you return only the LFO or only the tone, you can see how each respective signal behaves on its own in the time domain. It's worth noting that the LFO is oscillating between -1 and 1, so the phase of the tone is reversed on every cycle. You can fix this by keeping the LFO's value between 0 and 1 (<a href=".?code=DYUwLgBMBmD2EF4IGcCWA7AFGVBbEAVAEwEAKAkgJQHEBQokYs6IiKG2ehJFBALHwAMlWrQBO4AK5j0UOASYsgA%3D" target="_blank" rel="noopener noreferrer">squaring the value of the LFO is one way to do this</a>). Another useful way to modulate a signal is in a more saw-like approach where an LFO starts at one value and follows a linear path to a second value. This can be done in javascript by <a href=".?code=DYUwLgBCB2BuEF4IEYIFoIAowEsC2IEApCgJQBQokA7gIayFIDOO0mATAFQAKAkpwBYBABk64CFAE7gArpOhQ4EThDoMgA%3D%3D" target="_blank" rel="noopener noreferrer">using the modulo operator with a time variable.</a></p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Audio-Rate Modulation</h3>
            <div class="section-body">
                <p>What if we speed up an LFO such that it oscillates at the same rate as an audible tone? Well, the “O” wouldn’t be so “LF” anymore; it would just be a regular oscillator. The more general term for modulating the amplitude of one wave by another, regardless of frequency, is AM (amplitude modulation). Other common types of modulation are FM (frequency modulation), and PM (phase modulation), where one wave changes the frequency and phase of another respectively. Modulating signals like this is one (of many) approaches to creating waveforms with much more complicated timbres than those of the basic waveforms. For example, <a href=".?code=DYUwLgBGD2B2IQLwQM4EtYAoxoLYgCoAmAgBQEliiAGASgCh6Z4IDl0sd9izKAWanQLEmcBG1QZseQiQoEArINrCiolhI7TucygHZlqxgCdwAV2OwoYoA%3D%3D%3D" target="_blank" rel="noopener noreferrer">this</a> uses AM synthesis to generate a screechy metalic sound. The initial 220hz sine wave is multiplied by three different waves at 400, 500, and 700hz respectively.</p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Tones of Specific Frequency and Playing Notes</h3>
            <div class="section-body">
                <p>The function sin(x) (where x is radians) makes a full oscillation for every 2π increase in the input. If the input increases by one unit per second (like our time variable), then the sine wave oscillates once every 2π seconds. You can multiply the input by 2π to make it oscillate once per second, or at 1 hz. From here you can produce a sine wave that produces a tone at any arbitrary frequency in hz via multiplying the input by the desired frequency. For instance, <a href=".?code=E4UwLgrsB2AEDOBLaAKATAKgAoEkNkQFsQMAWUgBgEog" target="_blank" rel="noopener noreferrer">sin(2π*x*440)</a> will produce an output tone at 440 hz. This frequency (440 hz) also happens to be the frequency of the musical note A4 (this is just an arbitrarily decided standard). To get A5, the “A” note that’s one octave above A4, you just have to multiply the frequency of A4 by two (I.E. the frequency of A5 is 880 hz). To get notes other than “A” within the tuning system that most music in the western world uses (12-TET),  you simply multiply or divide the note’s frequency by the twelfth root of two to go up or down by one “semitone” which is the distance between adjacent notes. Multiplying “A” by the twelfth root of two results in A# (“A” sharp) or Bb (“B” flat) which are two names for the same note. Multiplying once again results in B, and multiplying a third time results in <b>C</b> rather than B# or Cb like you'd expect from the prior pattern. To see why this exception happens, take a look at the two octaves of this keyboard:</p>
                <br />
                <div class="flex justify-center"><img src="./img/keys.png" width=500 /></div>
                <br />
                <p>Not all the natural (white-key) notes have sharps/flats between them. Instead, “B” and “C” along with “E” and “F” are directly adjacent to each other. To play multiple notes at once, you can <a href=".?code=DYUwLgBAzpC8EAcD2B3AFAJgDQQIwHpcMBKCffKEAWwEswkA7EAKFEhTmjACpuMz8KABZJQEek2bNyDJGBBQINBhADGEKgEMAVkgBOEANYgAntPxUArsDA0EwExE0RZ8iACNHUJFRBKG8gDmIAYAZvoQSKpgmgBuCqzgahDwGABsuAB0aRgArGmJkAAmKWrcHIUQfvBF5WCVoaUg3DCVgaWhdZXO8IF1AqUALIMADJXupZpd5gDiIEx6mm7qWroGqiJ6RZVIlmAIe6Vju%2FuHANTwUMpo6tziNL583AAKAJLEzCcHkBfQ1353WyPDAvd6fPbfCC%2FK4MNDtQEPZogt4fZh6cCWPQqTIAZm4Xz2zCAA" target="_blank" rel="noopener noreferrer">add sine waves of the various frequencies you want to play together.</a> The reason that the twelfth root of two is used is because there are 12 notes in an octave, and you increase a frequency by one octive via multiplying 2; multiplying by 12 semitones is the same as multiplying by one octave.</p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; <i>Try It Yourself</i>: Making a Melody</h3>
            <div class="section-body">
                <p>A melody (at its simplest) is just different tones of multiple frequencies being played in a sequence. Try composing a melody by filling an array with notes! The notes supplied are just frequencies to put inside a sine function.</p>
                <br />
                <a href=.?code=DYUwLgBAzpC8EAcD2B3AFAJgDQQIwHpcMBKCffKEAWwEswkA7EAKFEhTmjACoYz8UACyRtGLNhADGEeBgBsuAHRyMAVjmtwEACYyp3Dpsgg92g2CMQAZnpC8LEgOZ6r5ywEM9j8%2Fz0AWPwAGSwAjPXc3ZnIIAGFBd2BQBkcQAC4IAFdKCDBBEwYkMBAoCHcGXRoGIoAnADcEkvcQpFqTeilGGGqMyUhPKhBgJG0AT2ZLAqKS%2BABtAH4AXV8EDMhJ4og86vEtdb11qBmrIaRqtDniBeiskwAiMBoBrFucvIgqYYyhiCQEEGr3PRqjgyroPtsckhoIMQL0fkwIHsrNUkFQILcDrdxtEEMB3CNStBKiYUO5WhAUHRBNZtgBHDIgBiSAlIGwYwogLHbMAZaoMIkMTDcAAKAEluA8BhBuBALkA%3D%3D%3D target="_blank" rel="noopener noreferrer">Melody Starter Code</a>
                <br />
                <a href=.?code=DYUwLgBAzpC8EAcD2B3AFAJgDQQIwHpcMBKCffKEAWwEswkA7EAKFEhTmjACoYz8UACyRtGLNhADGEeBgBsuAHRyMAVjmtwEACYyp3Dpsgg92g2CMQAZnpC8LEgOZ6r5ywEM9j8%2Fz0AWPwAGSwAjPXc3ZnIIAHkmRCQoKBoQ0GgRAFcwGkYIJBs0BAAnd0lsyXdgYABPUhoGK3q6FksGJDAQKD0AbUkcEBxHHG0cVxgcdwBdXwQsiDaOrsEQIvEtBZN4Dahuq2AkJCK0OW40RVVubKoQAFJcYmJJ6IzKCAAiK4G3iDBliCokNoMvs8ggVu56EUJgxdADVj8kNAQKAynl4htrEUkFR3ts3swovhEMB3NUIJ5kvEUO4AG4mFB0QSYkAARwyIAYkjJ%2BVx7RA%2BNWYAyRQY0HqmG4AAUAJKXGjXCDceZ84hAA target="_blank" rel="noopener noreferrer">Possible Melody Solution Code</a>
                <br />
                <p>This idea can quite easily be expanded to <a href=.?code=DYUwLgBAzpC8EAcD2B3AFAJgDQQIwHpcMBKCffKEAWwEswkA7EAKFEhTmjACoYz8UACyRtGLNhADGEeBgBsuAHRyMAVjmtwEACYyp3Dpsgg92g2CMQAZnpC8LEgOZ6r5ywEM9j8%2Fz0AWPwAGSwAjPXc3SyQAV05gywYkMBAoPQBtZggsiDTJHBAcRwBdHFz8wpKcvIgCiBDKspqceqxM7LTtHFcYHHdehs7re17%2B0sHusBGdbgwBruGIPrqStqy02u8e5dKNhZCcSXsZht2t%2Ff0YGZwzS9mdwr2Do%2Bwh25XsnJB8O9Wcy6tvu92pdHIDWh80u4isxoRJJMIAE7aABySRSekSySgaSswCQSARaFwcm4aEUAGZuGAaFQQABSXDEYjQ%2BEElFoqCKKwEgCi7nhaExIFgAD4AN6%2FGKQADU8CgNAYmG4AAUAJJUml2IUzYjcbiqZgAX2Iv2YzAR4GiCIYEEUGG4UrNQA%3D%3D target="_blank" rel="noopener noreferrer">playing chords and sequences of chords.</a></p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Amplitude vs Decibels vs “Loudness”</h3>
            <div class="section-body">
                <p>Amplitude refers to either the value of a single sample, or to the maximum value of an entire waveform, and it is a perfectly fine measurement for most cases. We’ve been using amplitude to measure signals so far, but another common measurement used in the field of DSP is that of the decibel. Decibels are a logarithmic unit with respect to amplitude, and that means linear changes in dB correspond to multiplicative changes in amplitude. In particular, an increase of about 6 dB is the same as doubling the amplitude, and likewise, a decrease of about 6 dB is the same as halving the amplitude. In the context of digital audio, decibels range from negative infinity to zero where zero is the loudest possible signal, AKA: an amplitude of positive or negative one. Since human senses are logarithmic rather than linear, decibels are a useful unit for capturing how “loud” a signal is. To demonstrate this, listen to <a href=".?code=DYUwLgBAhgtgDgZwgXggbQHQEYA0EMDMeADHhgBx64TEC6AUKJLHCtPAmgGbAD2vAJwAUYAJYwQAUgBsASgb0B4AK4CAduzgAqBKLVCATFoAKASS1iJWgCzXisoA" target="_blank" rel="noopener noreferrer">this loop</a> of a tone playing at four different amplitudes (not counting the amplitudes of zero). The increase of loudness between the first pair of amplitudes seems greater than that of the second pair of amplitudes. However, the increase in both cases is an equivalent 0.2. If you look at the increase using decibels instead of amplitude, the first increase is around 9.5 db, and the second is only around 1.9 db. The effect is more pronounced if you listen to this louder (but don’t listen <i>too</i> loud). You can convert amplitude to decibels via:</p>
                <br /><div class="flex justify-center"><img class="dark:invert w-1/3 my-2" src="./img/amp2db.png" width=500 /></div><br />
                <p>And the inverse is:</p>
                <br /><div class="flex justify-center"><img class="dark:invert w-1/3 my-2" src="./img/db2amp.png" width=500 /></div><br />
                <p>This all being said, decibels still don’t capture loudness perfectly, because different frequencies of equal amplitude are perceived as being different in loudness. <a href=".?code=OYGw9gRghiDKCmAXAFAcgGYCd4EdUBoACAFgAYBKAKFEhgDotdCAqAXkIEY7SfSPLKAS3TJEggLbxCAPk4VCYyYXakiNaCAbYcykqUIB6A%2BDAAHQvABu8TAE85hAM7wAxo4HZEAV0wA7J4K%2ByABMzAAKAJLMivDM6vSMOORAA%3D%3D%3D" target="_blank" rel="noopener noreferrer">Listen to this sine wave sweeping across the frequency spectrum!</a> Its amplitude remains the same, but the extreme lows and extreme highs still sound quieter than the middle frequencies. A unit that takes frequencies into account to be more accurate to loudness is LUFS, but the specifics of LUFS won’t be covered here (it’s not as important or common as amplitude and decibels).</p>
            </div>
        </div>

        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Noise and Its Colors</h3>
            <div class="section-body">
                <p>The term “noise” in the context of DSP refers to a signal with some element of randomness involved in its creation. The easiest type of noise to make is called “white noise,” and it’s just a (pseudo) random number generated for every sample. <a href=".?code=E4UwLgrsB2AEB0AmAVMAhtAJgCgJRA%3D%3D" target="_blank" rel="noopener noreferrer">Take a look at white noise in the time and frequency domains. </a> In the time domain, the signal is just a noisy mess, but the frequency domain is worth taking a closer look at. The properties of noise in the frequency domain is usually what’s used to differentiate between different types or “colors” of noise, and in the case of white noise, the frequency response is a (roughly) flat line with its height corresponding to amplitude of the noise in question. Another simple color of noise is “brown noise,” which is just the integral of white noise in the time domain. The frequency response of brown noise is a line with a slope of negative 6.02 decibels per octave, or in other words: for every increase of frequency by a factor of two, the amplitude decreases by a factor of two. Another common type of noise you’ll come across in the field of DSP is “pink noise,” which is similar to brown noise, but has half the slope (negative 3.02 decibels per octave). Pink noise has the useful property that each octave is roughly consistent in <i>volume</i> or <i>loudness</i> rather than amplitude. Another common type of noise is “blue noise,” and it’s <i>particularly</i> common in fields other than DSP (such as <a href="https://caseymuratori.com/blog_0011" target="_blank" rel="noopener noreferrer">game development</a>, and <a href="https://blog.voxagon.se/2018/12/07/the-importance-of-good-noise.html" target="_blank" rel="noopener noreferrer">computer graphics</a>). As far as DSP is concerned, blue noise is similar to the aforementioned colors of noise except that its slope in the frequency domain is <i>positive</i> 3.01 decibels per octave (the opposite of pink noise).</p>
            </div>
        </div>
        
        <div class="dropdown child-dropdown">
            <h3 class="section-title">&#8594; Putting it All Together; a Walkthrough of Making <a href=.?code=DYUwLgBA9grpC8EAMAoFB6dEDiIB2IATgIZggQASpAzhJiqJABakAyAYgPISICMEAWggAKAEwAqMAEsAtuQCkEXgEo66DtzBQIAYyh4whKMAhgm5YjIAOwKWBgATclABmEalDkQA7kzv4oKWoQFBYwDQhxPkERABZJWQUlVUwAWRhgaRsATwgAI1ziPAgIs1IAclowb21pOVoXYmoyQlNtahYrcjNyQiZssxlQti5IqIhRNVTiAGtu8xLRnRhCADdyByhvYsbmogx0dik8YmBgbIAaUz9aaikAcxOTIIhiBycHNuvnOCs4FFgkAA1IgAHS8WKRCBhDTiEh4BzCFLodKZKQ5b6LbgFdyeci%2Bfx4QLBV4IiDgyFaCAyWbzchhWgARxgUnA%2BwOOHwRFI5AA0lIdDM1AxwBAZgKZhFokJhHUkio1FivnoDEYTD1XtZbPYnBAAIIAOQAIhArHYdExoG5iO5jvjiOsUOLBRFxONeEhFdM5piIss1hstsUAGoAUQASgBNCC7SBUmk%2BuxiiUCbIiyDOmYAFX05EQdzwYnEAAUAJLiUSiJDiWWJeQK8TJl1cZFZhaZtoESoxwggZn4HS5F4yDJZWwgT44jUaFAQOfzueYBfLlcLgB6pkSEBecyskDy4G8IHwyFJn34Hh7fZgA6H1AM0Ie5laLigrWAPNawRVDmoALgEAguSABs4iZrCmY5gQagAMKeHkdpNkKERFJ8HZaAQVwjmiGI4qCwFfAm5DMqyLRXKhrzvF8gJ%2FGAaCYAaUBkLQFFmMc9y0G%2BEAfi0uIwAif6MNA7ypCATQrHmIigqIACsCReIoojKAAfPwmC%2BOAPStGxtAvEUwmfHI4m9um7gIKaWxiFcvDoLwSlqMEMh2LmpneOZzTiM0ai%2BMY4AuUJOg8BMwG8PhsnAaZnyIDo4huaZkkOLFdFCW4iAgJ5yWivcQUuElpk2og9xJYqiCxLEqBCXkQXEHlBy4AQJBkKaLAkjIUAOBkpBSPo%2BRNIJop5H1jHMUFADaOhXCAVz3FceRXA4Vy5c05GzQAuoqRIja%2BrSDdQVTaDYxBppVQ1MZJoIyVCu3UMNIDUKNLjAFAb7CAAHDW0lyXKECKCoyjrUuMAkv6vYPt9VLBKAOiQJt5CGiaRHbpA%2BlQNDDrkE9R6ECg123ZEiDtQ4onGSAAD8F0AFxqegIDrIQuRMc%2B1JidQEnbixxSo2A6PcVs%2BxCVYLWSQWtZyOgSniAAzNWItlvJ6W42dyIQMWQtWi4wSQNtzVNOQbUOP%2BwJghIIsSHLcriIrTVAjrwTK3qVEFva6w%2BHYlpWL2qzdaztvOC4GuilSNH%2FHVXKNRYhBWCgUguMIhPE6zvaqAA3moeQAfo5wQJsSMxlxhPMyT%2FXI5Ht20IgVt3flpdnUFkyNsQNfMQ9T0ve9Rbfb9yj%2FYqQPkCD%2BBxluEMgFDMO1%2FD1K0rnKNoy7fj3M%2Bple3kjXaIgSCYKC8QixbZvlsByLULYi%2BQKsjdSF1PXHL7hHtZ1TUao3VjdmaYAWtXVhSkoMTCPEnfJCmPfHidJNQ2DsI4bo2h7hSBdk%2FSO3Y%2BgDCYDIakb5%2B4sBINDfmopn5QWFscIs5tEjiGfnjG2K817KEwE7HwPNDrZHYq8Ju%2BI3YQEoaQKAKA8G5nxraQs%2B95akJYRWZWlhwE6j1sAq%2BxRvBsJtLQ7wPNeFcx5gvJePDoLjFNiWcsFsyFnSlmIrUEDdT6wft1WR8j%2BHO3IKFS6qj1i0HUfsQEgEwS8GEVYfBXiIiYDgjIBC0Fn6dlYWYEonB2DkTJNhMcuQ8L8APNtCw7wmFB1%2BP8AAvmgXs9hCCczgEAA target="_blank" rel="noopener noreferrer">This Loop</a></h3>
            <div class="section-body">
                <p>Making music via raw DSP is really just combining the tools you’ve learned about in interesting ways! To start making the demonstrated loop, <a href=.?code=DYUwLgBA9grpC8EAMAoNKBO4YYHbTiA%3D target="_blank" rel="noopener noreferrer">start with a variable to which we will add all our individual instruments’ signals.</a> The first instrument in question will be what’s called a “hi-hat” or just “hat” for short. <a href=https://en.wikipedia.org/wiki/File:Hi_hat_closed.ogg target="_blank" rel="noopener noreferrer">A hi-hat is a percussive instrument with a noisy, atonal, high-frequency sound.</a> To simulate one, you can just <a href=.?code=DYUwLgBA9grpC8EAMAoFB6dEDiIB2IATgIZggQASpAziqJABakAyAYgPISICMEAtBAAUAJgBUYAJYBbcgFII3AJQRMbTmCgQAxlDxhCUYBDANyxKQAdgEsDAAm5KADMI1KDIgB3BjfxQJ1CAoTGBqEKI8%2FEIALOLScgrKmACyMMCSVgCeEABG2cR4EGEmpADk1MaempIyFU7E1GSExprUTBbkJuSEDJkmUsEsHOEREMIq6MnEANadpkXDWjCEAG7kdlCehfWNRCiwkADUiAB03NHhECFqoiR4doJJk2kZwNldC5x5ru7k3r54fyBCAFOwQM4XDQQKQzObkEIVACOMAk4D2KEI4GWhQOQA%3D%3D%3D target="_blank" rel="noopener noreferrer">apply an LFO to whitenoise.</a> A neat trick being used here is the multiplication of two LFOs to shape the overall final LFO. I implore you to <a href=.?code=DYUwLgBA9grpC8EAMAoFB6dEDiIB2IATgIZggQASpAziqJABakAyAYgPISICMEAtBAAUAJgBUYAJYBbcgFII3AJQRMbTmCgQAxlDxhCUYBDANyxKQAdgEsDAAm5KADMI1KDIgB3BjfxQJ1CAoTGBqEKI8%2FEIALOLScgrKmACyMMCSVgCeEABG2cR4EGEmpADk1MaempIyFU7E1GSExprUTBbkJuSEDJkmUsEsHOEREMIq6MnEANadpkXDWjCEAG7kdlCehfWNRBjosJAA1IgAdNzR4RAhaqIkeHaCSZNpGcDZXQucea7u5N6%2BPD%2BQIQAp2CDnS4aCBSGZzcghCoARxgEnAexQhHAy0KNw4QA target="_blank" rel="noopener noreferrer">output the LFO itself to see how it behaves.</a> Not just for this hi-hat, but for any LFO or signal you want to understand better. The next instrument will be <a href=https://en.wikipedia.org/wiki/File:Bass_drum.ogg target="_blank" rel="noopener noreferrer">another percussive instrument known as the kick-drum or “kick” for short.</a> The process of creating it is similar to that of the hi-hat, <a href=.?code=DYUwLgBA9grpC8EAMAoFB6dEDiIB2IATgIZggQASpAziqJABakAyAYgPISICMEAtBAAUAJgBUYAJYBbcgFII3AJQRMbTmCgQAxlDxhCUYBDANyxKQAdgEsDAAm5KADMI1KDIgB3BjfxQJ1CAoTGBqEKI8%2FEIALOLScgrKmACyMMCSVgCeEABG2cR4EGEmpADk1MaempIyFU7E1GSExprUTBbkJuSEDJkmUsEsHOEREMIq6MnEANadpkXDWjCEAG7kdlCehfWNRCiwkADUiAB03NHhECFqoiR4doJJk2kZwNldC5x5ru7k3r54fyBCAFOwQM4XDQQKQzObkEIVACOMAk4D2GCwuAIJDIEAA0hItNMJnRwBBpoTpmFIgJBDUEkoJp8WtpdPpDMZ5uYrDZ7OQAIIAOQAIhALDYtAxoC5iK4JAQvMQ1igKUSwqJRtwkEyprNOeQwktVutNoUAGoAUQASgBNCA7SBQmF6mzkyl8TKkyCq6YAFV05EQ1HlIlEAAUAJKiYTCJCiOnxWSM0RutUcJ6%2B%2BY%2BloEcr2wggZH4LTZALQl4SHkgMHfD5qFAQRtNxuYZtt9vNgB6xniEDLswskBy4E8IHwyBB9wUP3zhZgxdL1D0VwkAHNTM0nFBmsBSERXCAdPdaAcIMdwQA2UQ%2Bm4%2B%2F0KzAAYXcOXl5GzYVBqeJGgIABpy3SSs3lybITgvFlnXIZFUSaACv2IOwwShA4LDgNAC1sQhCgOIA%3D target="_blank" rel="noopener noreferrer">but the LFO is much steeper and it controls frequency as well as amplitude.</a> The next instrument is an interesting one: <a href=.?code=DYUwLgBA9grpC8EAMAoFB6dEDiIB2IATgIZggQASpAzhJiqJABakAyAYgPISICMEAWggAKAEwAqMAEsAtuQCkEXgEo66DtzBQIAYyh4whKMAhgm5YjIAOwKWBgATclABmEalDkQA7kzv4oKWoQFBYwDQhxPkERABZJWQUlVUwAWRhgaRsATwgAI1ziPAgIs1IAclowb21pOVoXYmoyQlNtahYrcjNyQiZssxlQti5IqIhRNVTiAGtu8xLRnRhCADdyByhvYsbmogx0dik8YmBgbIAaUz9aaikAcxOTIIhiBycHNuvnOCs4FFgkAA1IgAHS8WKRCBhDTiEh4BzCFLodKZKQ5b6LbgFdyeci%2Bfx4QLBV4IiDgyFaCAyWbzchhWgARxgUnA%2BwOOHwRFI5AA0lIdDM1AxwBAZgKZhFokJhHUkio1FivnoDEYTD1XtZbPYnBAAIIAOQAIhArHYdExoG5iO5jvjiOsUOLBRFxONeEhFdM5piIss1hstsUAGoAUQASgBNCC7SBUmk%2BuxiiUCbIiyDOmYAFX05EQdzwYnEAAUAJLiUSiJDiWWJeQK8TJl1cZFZhaZtoESoxwggZn4HS5F4yDJZWwgT44jUaFAQOfzueYBfLlcLgB6pkSEBecyskDy4G8IHwyFJn34Hh7fZgA6H1AM0Ie5laLigrWAPNawRVDmoALgEAguSABs4iZrCmY5gQagAMKeHkdpNkKERFJ8HZaAQVwjmiGI4qCwFfAm5DMqyLRXKhrzvF8gJ%2FGAaCYAaUBkLQFFmMc9y0G%2BEAfi0uIwAif6MNA7ypCATQrHmIigqIACsCReIoojKAAfPwmC%2BOAPStGxtAvEUwmfHI4m9um7gIKaWxiFcvDoLwSlqMEMh2LmpneOZzTiM0ai%2BMY4AuUJOg8BMwG8PhsnAaZnyIDo4huaZkkOLFdFCW4iAgJ5yWivcQUuElpk2og9xJYqiCxLEqBCXkQXEHlBy4AQJBkKaLAkjIUAOBkpBSPo%2BRNIJop5H1jHMUFADaOhXCAVz3FceRXA4Vy5c05GzQAuoqRIja%2BrSDdQVTaDYxBppVQ1MZJu3UMNIDUKNLjAFAb7CAAHDW0lyXKECKCoyjrVgkxLjAJL%2Br2D4fVSwSgDokCbeQhomkR26QPpUBQw65D3UehAoBdV2RIg7UOKJxkgAA%2FKCMkAFxqegIDrIQuRMc%2B1JidQEnbixxQo2AaPcVs%2BxCVYLWSQWtZyOgSniAAzNWItlvJ6U42dyIQMWQtWi4wSQNtzVNOQbUOP%2BwJghIIsSHLcriIrTVAjrwTK3qVEFva6w%2BHYlpWL2qzdaztvOC4GuilSNH%2FCgvb2IQnNwEAA%3D%3D%3D target="_blank" rel="noopener noreferrer">a synthy bass sound with its timbre created via phase modulation!</a> On top of that, the notes from C to B are included along with the values for changing a note by a semitone or a wholetone (two semitones). A variable is also used to keep track of whether the current measure is odd so that every other measure has a slight variation. Finally an <a href=https://en.wikipedia.org/wiki/Arpeggio target="_blank" rel="noopener noreferrer">arpeggio</a>, or “arp” for short, is <a href=.?code=DYUwLgBA9grpC8EAMAoFB6dEDiIB2IATgIZggQASpAzhJiqJABakAyAYgPISICMEAWggAKAEwAqMAEsAtuQCkEXgEo66DtzBQIAYyh4whKMAhgm5YjIAOwKWBgATclABmEalDkQA7kzv4oKWoQFBYwDQhxPkERABZJWQUlVUwAWRhgaRsATwgAI1ziPAgIs1IAclowb21pOVoXYmoyQlNtahYrcjNyQiZssxlQti5IqIhRNVTiAGtu8xLRnRhCADdyByhvYsbmogx0dik8YmBgbIAaUz9aaikAcxOTIIhiBycHNuvnOCs4FFgkAA1IgAHS8WKRCBhDTiEh4BzCFLodKZKQ5b6LbgFdyeci%2Bfx4QLBV4IiDgyFaCAyWbzchhWgARxgUnA%2BwOOHwRFI5AA0lIdDM1AxwBAZgKZhFokJhHUkio1FivnoDEYTD1XtZbPYnBAAIIAOQAIhArHYdExoG5iO5jvjiOsUOLBRFxONeEhFdM5piIss1hstsUAGoAUQASgBNCC7SBUmk%2BuxiiUCbIiyDOmYAFX05EQdzwYnEAAUAJLiUSiJDiWWJeQK8TJl1cZFZhaZtoESoxwggZn4HS5F4yDJZWwgT44jUaFAQOfzueYBfLlcLgB6pkSEBecyskDy4G8IHwyFJn34Hh7fZgA6H1AM0Ie5laLigrWAPNawRVDmoALgEAguSABs4iZrCmY5gQagAMKeHkdpNkKERFJ8HZaAQVwjmiGI4qCwFfAm5DMqyLRXKhrzvF8gJ%2FGAaCYAaUBkLQFFmMc9y0G%2BEAfi0uIwAif6MNA7ypCATQrHmIigqIACsCReIoojKAAfPwmC%2BOAPStGxtAvEUwmfHI4m9um7gIKaWxiFcvDoLwSlqMEMh2LmpneOZzTiM0ai%2BMY4AuUJOg8BMwG8PhsnAaZnyIDo4huaZkkOLFdFCW4iAgJ5yWivcQUuElpk2og9xJYqiCxLEqBCXkQXEHlBy4AQJBkKaLAkjIUAOBkpBSPo%2BRNIJop5H1jHMUFADaOhXCAVz3FceRXA4Vy5c05GzQAuoqRIja%2BrSDdQVTaDYxBppVQ1MZJoIyVCu3UMNIDUKNLjAFAb7CAAHDW0lyXKECKCoyjrUuMAkv6vYPt9VLBKAOiQJt5CGiaRHbpA%2BlQNDDrkE9R6ECg123ZEiDtQ4onGSAAD8F0AFxqegIDrIQuRMc%2B1JidQEnbixxSo2A6PcVs%2BxCVYLWSQWtZyOgSniAAzNWItlvJ6W42dyIQMWQtWi4wSQNtzVNOQbUOP%2BwJghIIsSHLcriIrTVAjrwTK3qVEFva6w%2BHYlpWL2qzdaztvOC4GuilSNH%2FHVXKNRYhBWCgUguMIhPE6zvaqAA3moeQAfo5wQJsSMxlxhPMyT%2FXI5Ht20IgVt3flpdnUFkyNsQNfMQ9T0ve9Rbfb9yj%2FYqQPkCD%2BBxluEMgFDMO1%2FD1K0rnKNoy7fj3M%2Bple3kjXaIgSCYKC8QixbZvlsByLULYi%2BQKsjdSF1PXHL7hHtZ1TUao3VjdmaYAWtXVhSkoMTCPEnfJCmPfHidJNQ2DsI4bo2h7hSBdk%2FSO3Y%2BgDCYDIakb5%2B4sBINDfmopn5QWFscIs5tEjiGfnjG2K817KEwE7HwPNDrZHYq8Ju%2BI3YQEoaQKAKA8G5nxraQs%2B95akJYRWZWlhwE6j1sAq%2BxRvBsJtLQ7wPNeFcx5gvJePDoLjFNiWcsFsyFnSlmIrUEDdT6wft1WR8j%2BHO3IKFS6qj1i0HUfsQEgEwS8GEVYfBXiIiYDgjIBC0Fn6dlYWYEonB2DkTJNhMcuQ8L8APNtCw7wmFB1%2BP8AAvmgXs9hCCczgEAA target="_blank" rel="noopener noreferrer">generated using amplitude modulation.</a> All in all, while the entirety of this loop is a complicated program with many separate parts, you should be able to recognize each individual tool used to construct this loop.</p>
            </div>
        </div>

    </div>

    <p id="shared-msg" style="display:none;" class="text-center dark:text-white"><b>Playground's Code Was Supplied By URL!</b></p>

    <!--CUSTOM EDITOR DROPDOWN-->
    <div class="dropdown root-dropdown" id="playground-dropdown">
        <h3 class="section-title">&#8594; <b>PLAYGROUND</b></h3>
        <div class="section-body">
            <div class="flex mt-2">
                <div id="editor" class="w-1/2 h-80"></div>
                <div class="w-1/2 h-80">
                    <div style="height: 10%;" class="w-full text-center bg-gray-200 dark:bg-zinc-900 dark:text-white shadow-sm text-xl">
                        Time Domain
                    </div>
                    <canvas style="height: 40%" id="playgroundOsc" class="w-full" width="1560" height="256"></canvas>
                    <div style="height: 10%;" class="w-full text-center bg-gray-200 dark:bg-zinc-900 dark:text-white  text-xl">
                        Frequency Domain
                    </div>
                    <canvas style="height: 40%" id="playgroundFFT" class="w-full" width="1560" height="256"></canvas>
                </div>
            </div>
            <button onclick="toggleUserCode(this)" class="button-colors rounded-md px-2 py-1 mb-2"><b>Run</b>/Stop</button>
            <button id="rerun-btn" onclick="toggleUserCode();toggleUserCode()" class="button-colors rounded-md px-2 py-1 mb-2" style="display:none;">Re-Run</button>
            <button onclick="saveUserCode()" class="button-colors rounded-md px-2 py-1 mb-2">Save</button>
            <button onclick="shareUserCode()" class="button-colors rounded-md px-2 py-1 mb-2">Share</button>
            <p id="editor-err" class="text-red-700 dark:text-red-300"></p>
            <p>Volume:</p>
            <input id="vol-slider" oninput="setVolume(this.value)" type="range" min="0" max="100" value="100">
            <div class="dropdown child-dropdown">
                <h3 class="section-title">&#8594; How This Works</h3>
                <p>The code in this editor is executed in a function that is called for every processed sample; you just have to return a number for each sample.</p>
                <br />
                <h3><b>Button Descriptions:</b></h3>
                <ul>
                <li><i>Run/Stop</i> : Run or stop the audio generated by your code</li>
                <li><i>Re-Run</i> : If your code is already running, run it again immediately without stopping</li>
                <li><i>Save</i> : Save your code for your next visit to this site</li>
                <li><i>Share</i> : Generate a link that you can use to share your code</li>
                </ul>
                <br />
                <h3><b>Things You Can Use (on top of things already supplied by Javascript):</b></h3>
                <br />
                <ul>
                    <li><b>Variables</b></li>
                    <ul>
                        <li>time <i>(seconds)</i></li>
                        <li>sampleRate <i>(samples per second)</i></li>
                        <li>sampleNumber <i>(number of samples since beginning)</i></li>
                        <li>PI <i>(3.141592...)</i></li>
                        <li>global <i>(An empty JS object to store data that's persistent across samples. <a href=".?code=OYGw9gRghiDKCmAXAFAIjAV0agNAAgDoBmASjwHpz4BLRAC3gCc8B3WuvUSGBRAKD6UA8gCU8AWygA7DDBABPPtQBmyAITIA5GHpMA%2BpkSa81KZ3DQ4SEiQDefPI%2FPcQBHQ0YGseALyEiDk5clgT01IwAJl6Ivv4U5GEAzqzUICB4EPAmUrTUMNQAXvAReGBSAMZZUMks8Gl8AL4CjEgYjGbBMG5YQA%3D" target="_blank" rel="noopener noreferrer">Here</a> is a link showing how you can use it.)</i></li>
                    </ul>
                    <br />
                    <li><b>Functions</b></li>
                    <ul>
                        <li>sin(n), cos(n), tan(n) <i>(The trig functions for sine, cosine, and tangent)</i></li>
                        <li>pow(a, b) <i>(Raises a to the power of b, and returns the result)</i></li>
                        <li>min(a, b, ...), max(a, b, ...) <i>(functions that return the lowest and highest values of what you pass into it)</i></li>
                        <li>round(n) <i>(rounds n to the nearest integer)</i></li>
                        <li>floor(n), ceil(n) <i>(functions that round down and round up floating point numbers respectively)</i></li>
                        <li>abs(n) <i>(Take the absolute value of a number)</i></li>
                        <li>globalSet(variable, value) <i>(Initialize a persistent variable with a value. Variable name has to be passed in as a string!)</i></li>
                        <li>lerp(a, b, t) <i>(Linear interpolation between a and b with ratio t between 0 and 1)</i></li>
                        <li>clamp(value, low, high) <i>(return value or the lower/upper limit if value is outside of the bounds)</i></li>
                        <li>rand() <i>(Random value between -1 and 1)</i></li>
                    </ul>
                </ul>
            </div>
        </div>
    </div>

    <!-- I don't think we'll be needing this
    <div class="text-center">
        <h6 class="mt-2">interactive demo (WIP)</h6>
        <button onclick="onTestButtonClicked()" class="bg-slate-200 hover:bg-yellow-100 rounded-md px-2 py-1 mb-2">Run Demo</button>
    </div>
    -->
    

    <!-- PLAN (so far)...
        PROGRAMMING: sine waves & other waves
        user has task to make a sine wave, specifics tbd (but include some basics about pitch and multiplying the input)??
        user can try adding multiple sine waves.

        Another common type of wave: saw wave
        first user makes saw wave via mod func,
        then user does the same via adding sine waves according to the fact that each harmonic in a saw wave is sin(nx)/n.

        Same with square waves
        user can try subtracting a saw wave one octave higher from the original saw wave
        OR can add the harmonics manually

        TODO:
        noise and (its colors)
        filtering
        modulation of signals (pitch and vol LFOs and FM/AM/PM synthesis)
        Basic programmatic sequencing
    -->

    <!--<script src="js/main.js"></script>-->
    <script src="js/dsp.js"></script>
    <script src="js/scopes.js"></script>

    <!--Dropdown script-->
    <script>
    //NOTE: it could be convenient to cache the status of which dropdowns are visible for future visits
    function toggleDropdown(e) {
        // Flip visibility of children
        Array.from(e.children).forEach((c,i) => {
            if(i===0) return
            if(c.dropdown_originalDisplay === undefined) c.dropdown_originalDisplay = c.style.display //janky?
            c.style.display = c.style.display === 'none' ? c.dropdown_originalDisplay : 'none'
        })
        // Change dropdown arrow
        e.isOpen = !e.isOpen
        if (e.classList.contains('dropdown')) {     
            if(e.isOpen) {
                e.querySelector('.section-title').innerHTML = e.querySelector('.section-title').innerHTML.replace('→', '↓')
            } else {
                e.querySelector('.section-title').innerHTML = e.querySelector('.section-title').innerHTML.replace('↓', '→')
            }
        }
    }

    var toggleEverythingDropped = false;
    function toggleEverything(eBtn){
        Array.from(document.getElementsByClassName("dropdown")).forEach(e => {
            Array.from(e.children).forEach((c,i) => {
                if(i===0) return
                 c.style.display = toggleEverythingDropped ? 'none' : c.dropdown_originalDisplay
            })
        })
        toggleEverythingDropped = !toggleEverythingDropped
        // Change all arrows
        if (toggleEverythingDropped) {
            Array.from(document.getElementsByClassName("dropdown")).forEach(e => {
                e.isOpen = true;
                e.querySelector('.section-title').innerHTML = e.querySelector('.section-title').innerHTML.replace('→', '↓')
            })
        } else {
            Array.from(document.getElementsByClassName("dropdown")).forEach(e => {
                e.isOpen = false;
                e.querySelector('.section-title').innerHTML = e.querySelector('.section-title').innerHTML.replace('↓', '→')
            }) 
        }
        eBtn.innerHTML = toggleEverythingDropped ? 'Hide Everything' : 'Show Everything'
    }

    Array.from(document.getElementsByClassName("dropdown")).forEach(e => {
        e.getElementsByClassName('section-title')[0].onclick = () => toggleDropdown(e)
        e.isOpen = true;
        toggleDropdown(e)
    })
    </script>

    <!-- Manage shared or saved code BEFORE initializing the editor(b/c the editor takes a second to load) -->
    <script src="./js/lz-string.min.js" type="text/javascript" charset="utf-8"></script>
    <script>
    var code = (new URL(window.location)).searchParams.get('code')
        if(code !== null){
            document.getElementById('shared-msg').style.display = ''
            code = LZString.decompressFromBase64(decodeURIComponent(code))
            toggleDropdown(document.getElementById('playground-dropdown')) //slightly janky b/c toggle expects that all dropdowns are initially hidden
        }else
            code = (localStorage.getItem('code') === null) ? `//phasey saw!
let f = 110 //frequency
let v = 0 //output sample
let h = 50 //number of harmonics
for(let i = 1; i < h; i+=1)
    v += .15*sin(2*PI*i/50.0 + time)*sin(time*PI*f*i)/i
return v` : localStorage.getItem('code')
    </script>

    <!-- desmos stuff for some graphics -->
    <script src="https://www.desmos.com/api/v1.7/calculator.js?apiKey=dcb31709b452b1cf9dc26972add0fda6"></script>
    <script src="js/calculator.js"></script>

    <!--Editor stuff-->
    <script src="./js/ace/src-min/ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="./js/ace/src-min/theme-twilight.js" type="text/javascript" charset="utf-8"></script>
    <script src="./js/ace/src-min/mode-javascript.js" type="text/javascript" charset="utf-8"></script>
    <script>
        var editor = ace.edit("editor");
        var JavaScriptMode = ace.require("ace/mode/javascript").Mode;
        editor.session.setMode(new JavaScriptMode());
        editor.setValue(code)

        const fftCanvas = document.getElementById("playgroundFFT")
        const oscCanvas = document.getElementById("playgroundOsc")
        const oscCtx = oscCanvas.getContext("2d");
        const fftCtx = fftCanvas.getContext("2d");
        clearScopes(oscCanvas, fftCanvas, oscCtx, fftCtx)

        function saveUserCode(){
            localStorage.setItem('code', editor.getValue())
            alert('Code Saved for Next Vist!')
        }

        var userCodeRunning = false
        function toggleUserCode(btn){
            if(userCodeRunning){
                closeDSP()
                userCodeRunning = false
            }else{
                setDSPsimple(editor.getValue())
                userCodeRunning = true
            }

            if(typeof btn !== 'undefined'){
                btn.innerHTML = userCodeRunning ? 'Run/<b>Stop</b>' : '<b>Run</b>/Stop'
                document.getElementById('rerun-btn').style.display = userCodeRunning ? '' : 'none'
            }
        }

        function shareUserCode(){
            let codeURL = (new URL(window.location)).host + '?code=' + encodeURIComponent(LZString.compressToBase64(editor.getValue()))
            navigator.clipboard.writeText(codeURL).then(function() {
                alert('Link Copied to Clipboard!');
            }, function(err) {
                alert('Unable to Copy to Clipboard: ', err);
            });
        }

        function setVolume(value){
            dspSetVolume(value/100)
            localStorage.volume = value
        }

        if('volume' in localStorage) document.getElementById('vol-slider').value = localStorage.volume
    </script>

    <!--Dark Mode Listener Script-->
    <script>
        function setThemeToPrefered(){
            let dark = localStorage.useDarkMode === 'true'
            if (dark) {
                document.documentElement.classList.add('dark')
                setCalculatorColorInversion(calculators, true);
                editor.setTheme("ace/theme/twilight");
            } else {
                document.documentElement.classList.remove('dark')
                setCalculatorColorInversion(calculators, false);
                editor.setTheme(0);
            }
            // Change scope color (clears canvas but thats not too big of a problem)
            scopeBGColor = dark ? scopeBGDarkColor : scopeBGLightColor
            scopeLineColor = dark ? scopeLineDarkColor : scopeLineLightColor
            clearScopes(oscCanvas, fftCanvas, oscCtx, fftCtx)

            document.getElementById('darkmode-btn').innerHTML = dark ? 'Use Light Mode' : 'Use Dark Mode'
        }
        // Set bg and scope line color initially
        const dt = window.matchMedia("(prefers-color-scheme: dark)");
        scopeBGColor = dt ? scopeBGDarkColor : scopeBGLightColor
        scopeLineColor = dt ? scopeLineDarkColor : scopeLineLightColor
        clearScopes(oscCanvas, fftCanvas, oscCtx, fftCtx)
        // Add dark mode listener
        dt.addListener(e => setThemeToPrefered(e.matches));
        if(!('useDarkMode' in localStorage)) localStorage.useDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
        setThemeToPrefered()

        function invertTheme(){
            localStorage.useDarkMode = localStorage.useDarkMode === 'true' ? false : true
            setThemeToPrefered()
        }
    </script>
</body>
</html>
